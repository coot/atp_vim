*automatic-tex-plugin.txt* LaTeX filetype plugin	Last change: 12 April 2014

	    An Introduction to AUTOMATIC (La)TeX PLUGIN (ver. 12.5)
			by Marcin Szamotulski
		    mszamot [AT] gmail [DOT] com
-----------------------------------------------------------------------------

If you found this plugin useful or you have any kind of problems with running
it or some ideas to share, you are cordially invited to write to me:
mszamot@gmail.com.  Voting at Vim site is also welcome ;) .

-----------------------------------------------------------------------------
			    ABSTRACT ~

This is a filetype plugin for Vim to comfortably write [TeX], [LaTeX],
 [PdfLaTeX],...  documents, which provides functionality not met in other
plugins.  It makes you [FREE] from compiling procedure, making this process
automatic using autocommands.  It also provides useful mappings and other
many other commands: to analyse your .log file, to see the table contents, to
search for a label, to search in bib files or to find a macro definition
matching a pattern, or even to find and preview fonts in your tex
distribution.  The features include a multi-functional tab completion for:
commands, environment names, packages, input files, bib files, bst files,
colours, closing brackets and environments (preserves nesting),... etc.  To
have full functionality you need: python (with nonstandard psutil library, see
|atp-requirements-python| how to get it), pdffonts available in the package
'app-text/poppler' (at least in Gentoo).  Another good tool is texdoc, which
is a part of TexLive - these days standard TeX distribution for Linux, and
MikTeX on Windows.
------------------------------------------------------------------------------

			FEATURES INCLUDE: ~
------------------------------------------------------------------------------
* background compilation, debugging modes, progress bar
* command to make the document (cross references, references, index, tables
  of contents) |atp-:MakeLatex|,
* completion for commands, closing environments (even nested), package names,
  citations and labels.  Support for some latex packages,
	see |atp-completion|, 
* forward/inverse searching:
  	see |atp-:SyncTex|, |atp_inverse_search|,
* table of contents which allows to switch between different sections, files, 
  but also to delete and paste sections:
	see |atp-:Toc|, |atp-toc-window|,
* list of labels which allows to see the context of a label:
	see |atp-:Labels|,
* a command to get bib data from the AMSRef web page http://www.ams.org/mathscinet-mref:
	see |atp-:AMSRef|,
* a powerful function to search in bibliographic files (bib files):
	see |atp-bibsearch|,
* a command to list ToDo lines:
	see |atp-:ToDo|,
* a command to search for a macro definition (multi-line support):
 	see |atp-:Dsearch|,
* a command to search and PREVIEW fonts in your latex distribution:
 	see |atp-:FontSearch|, and |atp-:FontPreview|,
* indentation.

==============================================================================
SOURCEFORGE						*atp-sourceforge*

  - The project is hosted on SourceForge:
    http://sourceforge.net/projects/atp-vim/

SUPPORT     						*atp-support*
>
    Please consider to a [DONATION] for this project.  You can do that
    through your [PayPal] account (my email is <mszamot [AT] gmail [dot]
    com>).  This will be highly appreciated.

							Thank You. ~
    You can use this link:							
    https://www.paypal.com/cgi-bin/webscr?cmd=_s-xclick&hosted_button_id=3NMU7FEEPVG7Q
<
  							*atp-mailing-list*
  - There is a mailing list which will serve for: feature requests, bug
    reports, suggestions.  You can subscribe at:
    https://lists.sourceforge.net/lists/listinfo/atp-vim-list

  - There is also a new wiki page: (as for now it only includes features of
    ATP - it looks nice :)
    http://sourceforge.net/apps/mediawiki/atp-vim/index.php?title=Main_Page

  - For detailed list of changes you can look at:
    http://atp-vim.git.sourceforge.net/git/gitweb.cgi?p=atp-vim/atp-vim;a=log

  - Project news can be tracked through sourceforge watch feature (you need
    sourecforge account)

  - SourceForge hosts stable releases (also available on Vim web page) but
    also snapshots of unstable developed new version.  The snapshots might
    contains fixes and new features which might not yet work well, or might
    change (commands, maps, etc ...).
    

==============================================================================
TABLE OF CONTENTS 					*atp*
                                                	*atp-help-toc*
	|atp-news|			News.
	|atp-installation| 		Installation.								
	    |atp-on-Windows|
	    |atp-and-other-plugins|
	|atp-commands| 			Functions and commands:
	some most important commands: ~
	    compile ~
		|atp-:Tex|
		|atp-:MakeLatex|
		|atp-:Bibtex|
		|atp-:DebugMode|
		|atp-:ShowErrors|
		|atp-:ErrorFormat|
		|atp-:Kill|
	    view ~
		|atp-:View|
		|atp-:SyncTex|		forward searching,
	    diff ~
		|atp-:Wdiff|
	    motion ~
		|atp-:Toc|
		|atp-:F|
		|atp-:B|
		|atp-:Tags|		make tags file,
	    search ~
		|atp-:Dsearch|		definition search,
		|atp-:S|		search in projects.

	|atp-toc-window|		Commands/maps defined in Table of Contents window 
				      and Labels window.  Includes folding from toc.
	|atp-folding|			Folding.
	|atp-bibtex|			File type plugin for bibtex.
	|atp-bibsearch|			Searching in bib files.
	|atp-completion|       		How to use and configure completion
	|atp-configure| 		How to configure to your needs.
	|atp-ProjectFiles|		A note how to write project files within ATP.
	|atp-ProjectScript|		A script executing project specific settings.
	|atp-mappings|  		Mappings.
	    |atp-imaps|
		|atp-imaps-fonts|
		|atp-imaps-greek-letters|
		|atp-imaps-environments|
		|atp-imaps-math-misc|
		|atp-imaps-math|
		|atp-imaps-diacritics|
	|atp-abbreviations|		Abbreviations.
	|atp-errors|  			Debugging ATP.
	|atp-editing|			Editing tools.
	|atp-requirements|  		Requirements.
	|atp-viewers| 			Note about viewers,
					with [reverse_searching] for Okular, Xpdf and Skim
	|atp-tips|			Some tex oriented tips.
	|atp-highlight|			Colours and syntax files.
	|atp-remarks|  			Final remarks.
	|atp-development|
	|atp-copy-rights|		Copy Rights.

	
Note on usage: type :help atpCTRL-d to see all the helptags.  To see help tags
for all the defined functions :help atp*()CTRL-d, mappings: :help atp-mapCTRL-d

================================================================================
NEWS							*atp-news*
>
 =======================
 Changes in version 12.4
<
 Just a few bug fixes and the documentation get updated.
>
 =======================
 Changes in version 12.3
<
 |atp-:TexAlign| with range (and new vmap <LocalLeader>a).

 |g:atp_fold_environments| is a list of environments which will be folded.
 (To enable folding you have to set |g:atp_folding| on start-up).

 You can use |atplib#motion#ctoc()| function to show the current section in
 the status line.

 If you close window with |:quit| command, and there are at most two window
 left: the label window or the table of contents window, they will be closed
 with the |:quit| command too.  This will close the current tab or quit vim if
 you have only one tab.

 "n" is added to 'foromatoptions' is set and the 'formatlistpat' is set to
 recognize the \item LaTeX command.

 |atp-:Preamble| shows preamble in a scratch buffer.  If 
    http://www.vim.org/scripts/script.php?script_id=4296
 is installed, the buffer is editable.

 |g:atp_packages| variable is automatically updated if you add a package using
 ATP completion function.  This extends the pool of commands, environments
 for completion by the ones which are provided by the package.

 Completion for optinal values of commands.  For now only \includegraphix[] is
 supported.
 
>
 =======================
 Changes in version 12.2
<
>
 You can support this project:
https://www.paypal.com/cgi-bin/webscr?cmd=_s-xclick&hosted_button_id=3NMU7FEEPVG7Q
>

 Thanks,

		    Marcin Szamotulski
<

 |atp-}e|, |atp-{e|,  |atp-}E|, |atp-{E| rewritten from scratch (see the nice
 graphical explanation therein).  Furthermore, the default value of
 |g:atp_map_forward_motion_leader| is '}' (|g:atp_map_backward_motion_leader|
 is '{').  Setting it to ']', '[' colides with |]s| and |[s| which are quite
 useful.

 New motions |atp-}o|, |atp-{o|.

 |atp-:Tex|, |atp-:Texl|, |atp-:Dtex|, |atp-:Pid| instead of :Tex, :Texl,
 :Dtex, :Pid.  I think it is easier to type.

 |atp-gW| instead of gw (if you prefer the previous map you can redefine in
 your |atprc| file with: >
    nmap gw <Plug>FormatLines
< (in |vimrc| file you have to use an autocommand).

 The map g< and g> are removed (indenting inner paragraph).  If you still want
 to use them put this in your |atprc| file: >
    nnoremap <buffer> g>	:<c-u>call feedkeys("m`vip".(v:count1 <= 1 ? "" : v:count1).">``", 't')<cr>
    nnoremap <buffer> g<	:<c-u>call feedkeys("m`vip".(v:count1 <= 1 ? "" : v:count1)."<``", 't')<cr>
<

 You can set |b:atp_OutDir| with |atp-:SetOutDir| command (it also updates the
 |errorfile| option.

 USE AT-YOUR-OWN-RISK - added to the license ;)
>
 =======================
 Changes in version 12.1
<
 |g:atp_HighlightMatchingPair| to turn on/off higlighting of matching pairs
 (begin/end which might be slow on a slow computer).

 If you set |g:atp_SelectInlineMath_withSpace|=1 |atp-im| will select the
 space just after/before \(:\).

 A few reported bug were fixed.

>
 =====================
 Changes in version 12
<

 The default values of |g:atp_map_forward_motion_leader| has changed to "]"
 and |g:atp_map_backward_motion_leader| to "[".

 New |atp-gD| normal command.

 |atp-:Texdoc| and |atp-:Texdef| instead of |atp-:TexDoc|, |atp-:TexDef|.
 |atp-:Texdef| defined only if |g:atp_developer| is 1.

 |g:atp_diacritics| variable: switched the values, now 2 (for diacritics: a''
 -> accented a) and 1 (normal imaps).

 If you don't want the ruler in the ATP status set the vim option |'noruler'|
 and use the command |atp-:Status| (or |atp-:ATPStatus|).

 |atp-:Texl| and the \\l map supports count.
 There are two maps to |atp-:SyncTexl|: \\f (like \\l) and \F.

 completion: if you use subfiles packages the completion for \ref{} and
 \eqref{} also looks inside the subfile .aux file.

 If subfiles packge is used, the local aux file is searched for labels
 (completion).

 If you don't like the maps associated to a given leader (|g:atp_imap_leader_1|,
 ...) put define the variable to be an empty string in your |vimrc| or |atprc|
 file.

 The motions { and } are adding entries to the jump list, by setting the
 ` mark.  This is the default behaviour in vim (see |jump-motions|) The same
 aplies to the |atp-:S| command.

 Read this note: |atp-completion-new-packages|.
>
 =======================
 Changes in version 11.1
<
 Hi, 
    I have put ATP on fundageek - a rais funding platform: 
    http://www.fundageek.com/project/detail/353/LaTeX-plugin-for-Vim

    I am forced to do that, since my laptop is not working properly and I need
    a replacement.  Please share the link among people who would like to
    support this project.

 Best regards,
    Marcin


 Note: ~/.vim/ftplugin/ATP_files/atp_RevSearch.py was moved to
 ~/.vim/ftplugin/ATP_files/reverse_search.py.  You might need to udpat the
 config file of your browser (Okular, Xpdf, etc.)

 gf	    - works faster if vim is compiled with |+python| interface.
 C-XC-O	    - closing brackets: a small bug fixed.
 vip	    - better support for "\begin{...}[...]\label{...}".
 Tex!
 MakeLatex! - with the bang "!" the commands writes (using |update| command)
	      all the loaded project buffers.
>
 =====================
 Changes in version 11
<
 NOTE: You should remove the file:
     ~/.vim/ftplugin/ATP_files/packages/amsmath.vim
 Then ATP completion will work better, since ATP can now scan package and
 documentclass files (.sty, .cls) for commands and options.

 NOTE: I change the name of the script at vim.org to AutomaticLaTeXPlugin
 (with capital X), if you install ATP via Vim-Addon-Manager (or other vim
 plugin manager) this might affect path were the atp_RevSearch.py script is
 located.  In this case you might need to adjust the setting of reverse search
 in your viewer (Okular, Xpdf, ...).

 NOTE: It was found that 'relativenumber' option slows down vim when edditing
 tex files (at least for some users).

 QUICK REFERENCE GUIDE:~
 You can download a quick reference guide for ATP from:
     http://atp-vim.sourceforge.net/atp_quickref.pdf
 It should be easier now to go through ATP features.

 If you set |g:atp_ParseLog| and |g:atp_Compiler|="python", then ATP will
 rewrite the log file so that the output is readable for vim |quickfix| using
 |errorformat|.  The advantage is for project files, where it is important to
 correctly read the file position of the error.  In addition there is one more
 |atp-:ShowErrors| flag 'O' which shows 'overfull \hbox' messages.  Also note
 that the flag 'w' (for warnings) excludes font warning messages.  
 NOTE: See also |atp-:Cgetfile| (!!! This command is only defined for vim version
 < 7.3.468, my patch 468 introduces a new autocommand which is used to rewrite
 the log file, so check out the latest vim version !!!).

 |atp-:ErrorFormat| accepts "+{+flag}-{-flag}" as an argument.

 |g:atp_Signs|=0 by default.

 |g:atp_indent|=1 by default, then LatexBox indentation file is used.   

 |atp-gf| works well with \bibliography{} command.

 See ':help atp-omap-<C-d>' for the defined operator maps. 
 |atp-vi(|, ... , |atp-va}| maps.

 Support for subfiles.sty package:~
 Compilation of parts of a project (using subfiles package).
 |atp-:Texl|, |atp-:Viewl|, |atp-:SyncTexl|, see also |b:atp_autex| (when set
 to 2 automatic compilations of subfiles is turned on).

 |atp-:S| command has additional flag 'x', when used the
 |v:searchforward| value will not be changed.

 TABLE OF CONTENTS:~
 |atp-:Toc| was rewritten in python so that it works well with project files.
 If your vim is compiled without python the old ToC will be used. 

 Toc and Labels windows are clicable: acts like <space> = go to section and
 leave Toc/Labels window open. 
 See also |atp-:RemoveFromToC| command.

 NEW DEBUG MODES:~
 See |atp-autosilent|, |atp-autodebug| and |atp-autoDebug| debug modes.
 Previously, by default QuickFix window was closed when there was no error.
 Now this behaviour is reserved only for |atp-autosilent|, |atp-autodebug|,
 and |atp-autoDebug| modes.

 omap \w and vmap \w to repeat last wrapping command (like \it, \sf, \em, ...)
 (see |atp-omap-\w| and |atp-omap-WrapSelection|)

 See |g:atp_diacritics| (used instead of g:atp_imap_diacritics_inteligent).

 |atp-:ErrorFormat| and |atp-:ShowErrors| have a flag 'h' instead of 'O' which
 shows both 'Underfull \hbox' and 'Overfull \hbox' messages'.

 Local project script (.project.vim file) may contain |:set|/|:setl|
 statements which will be executed after |vimrc| and |atprc| files.
 These statements are executed only once (per project file).

 CHANGE IN MAPS: ~
 As suggested by F.Heiderich: #< and #> are now maps for \langle and \rangle.

 New commands: |atp-:Texdef|, |atp-:KpsewhichEdit|.  They are defined in
 plugin/tex_atp.vim script, so you can use them not only inside tex files.
>
 =========================
 Changes in version 10.6.4
<
 ATP normal r map is working better, that is |.| works well with |atp-r| map.

 |g:atp_OpenAndSyncSleepTime| = "500m"	-- sleep time between the time when
 ATP finds the viewer working and syncing (forward searching) for the command
 |atp-:View|! (with bang) (this is time left for the viewer to open the file).

 Plus some new package files for completion: showidx, makeidx, syntonly and
 a better completion for the \includeonly{} command (which removes items from
 completion menu which are already included).

 Count added to |atp-]%| and |atp-[%|.

 |atp-:TexAlign| works with smallmatrix environment.

 Completion scans package and documentclass files for options (if vim is
 compiled with |+python|).
>
 =========================
 Changes in version 10.6.3
<
 A small bug fixed when opening a new tex buffer.

 Omni completion changed:
	 (Expert Mode) Tab Completion is mapped to <C-X><C-O>
     (Non Expert Mode) Tab Completion is mapped to <C-X>o
 This is the default, if you want to use <Tab> and <S-Tab> keys set
 |g:atp_tab_map| to 1 in your |vimrc| or |atprc| file.

 For some reasons it is better to map completion to <C-X><C-O> than to use
 'omnicomplete' option (as it was done in 10.6.2).  Using the option sometimes
 issues errors (when modifying text) also setting cursor position to the right
 place is impossible (in more advanced completions, like closing
 environments).

 Note also that g:atp_no_tab_map has changed to |g:atp_tab_map|.
>
 =========================
 Changes in version 10.6.2
<
 Omni completion	-- ATP Tab completion now works as Omni Completion, see
			   |compl-omni|, the non expert mode completion is
			   mapped to <F7> key.  The <Tab> key is not mapped.
			   If you want to use <Tab> and <S-Tab> for
			   completion, as it was done before, just put 'let
			   |g:atp_tab_map|=0' in your |vimrc| or |atprc|
			   files.

			   Note that omni completion might give the 'Pattern
			   not found' error, when closing environments or
			   brackets - you can ignore this message (it is not
			   possible to turn it off, and working it around will
			   take to much time).
	
 	completion	-- memoir document class completion: document class options,
			   and some commands,
			-- bibref package added.

 % motion		-- changes the jump list (this is vim compatible
			   behaviour (see |jump-motions|)
			-- omap % added.  Now to delete an environment just
			   put the cursor over \begin or \end command and use
			   'd%'.  The same will work if you want to delete
			   (:), [:], {:} or $:$ pairs.

 { and } normal motions	-- also work in visual mode (see |}| and |{|).

 |atp-:Yank| and |atp-:Paste| (inside bib search) changed.  Also yanking in
 toc (the section key) is in more vim style.

 |atp-:PasteSection| with bang "!" puts section before rather than after.

 At the end of |atp-tips| I show how to make w b and aw work slightly better
 (this is experimental code). 

 |atp-:ChangeLabel|       -- a new command for changing labels across the
			   project.

 |atp-:WordCount|         -- range added, if the file type is 'tex' also
			   doesn't count the preambule.

 |atp-:View| 		-- instead of :ViewOutput command.
>
 =========================
 Changes in version 10.6.1
<
 In the |atp-:BibSearch| window:
 :BibChoose is now split into two commands: 
 |atp-:Yank| and |atp-:Paste|, the maps 'y', 'c' and 'p', 'P' can be invoked
 with a count. |atp-:Yank| by default uses the " register.

 |atp-:SyncTex| is now mapped to |atp-\f|, instead of t, which was not
 compatible with |t| vim command.  It is easy to remember |atp-\f| = like forward
 search ;)

 New normal mode wrapping operator maps: see |atp-nmap-fonts| and
 |atp-nmap-bracket-wrappers|.

 Commands to find maps:
    :Map[!]  {pattern}			|atp-:Map|
    :Nmap[!] {pattern}			|atp-:Nmap|
    :Imap[!] {pattern}			|atp-:Imap|
    :Smap[!] {pattern} 			|atp-:Smap|
    :Vmap[!] {pattern}			|atp-:Vmap|
    :Omap[!] {pattern}			|atp-:Omap|
    :Lmap[!] {pattern}			|atp-:Lmap|
There is another plugin: MapFinder 
    http://www.vim.org/scripts/script.php?script_id=3767
which defines them.  The only Imap differs, here it is more specific to ATP,
since ATP defines and deletes some imaps on the fly not all of them are
visible with :imap command.

>
 =======================
 Changes in version 10.6
<
 The command |atp-:View| with bang (also <F3> map) opens and makes forward search.
 Reverse search (atplib#FindAndOpen() function) sets the "'" mark before
 changing text position.

 Folding: ~
 See |atp-folding| - thanks to Johannes Zellner for the simple (and fast)
 folding script.

 Imaps: ~
 ->, <- in tikz picture environment (but not in math) puts \draw[->] or \draw[<-].
 They are also disabled inside [:].

 Vmaps: ~
 'o, 'u	instead of 'ov and 'uv (\overline, \underline).  This is compatible
 with imaps 'o and 'u.

 Some bug fixes.  For example the algorithm for closing brackets is more
 reliable (should work in 100% cases ;).

 Cmap: ~
 <space> cmap for \_s\+, if |\v| is included (very magic) in the pattern (any where) then
 \_s+ is used as rhs.

>
 =======================
 Changes in version 10.5
<
 Thanks for all the vim karma points: if you look at all ftplugin scripts ATP has 8th
 rate and among ten most rated plugins it has 2nd best average rate: 3.71, while the
 first one has 3.73.  If you find something in ATP which is not convenient, or
 you think it might be done in a more friendly way, let me know, I'm open for
 discussions :) 

 Here are the recent changes (excluding bug fixes):

 Signs			-- see |atp-signs| (and |signs|).
 :Unwrap		-- see |atp-:Unwrap| command (nmap <LocalLeader>u).

 See added note below |g:atp_texinputs|.
 The package variable names are changed, see |atp-completion-packages|.
>
 =======================
 Changes in version 10.2
<
  Skim (MacOS)                  -- support for "Skim" added (forward search)
                                   [thanks to Florian Heiderich].
                                   Read the necessary steps in |atp-Viewers-Skim|.

  Xpdf				-- support for inverse searching added (Xpdf -> vim)
				   thus both inverse and forward searching
				   works for Xpdf (and Okular).  See
				   |atp-Viewers-Xpdf| how to set it.

  :MakeLatex [mode]		-- mode is one of silent/debug/Debug.  Will
				   also show bibtex/biber/makeidx error
				   code/debug info.

  :Dictionary {word}		-- an interface to http://www.impan.pl/Dictionary/.
  					see |atp-:Dictionary| (with map =d
					using |<cword>| under the cursor).

  |atp-:Edit|			-- instead of :EditInputFile

  :ShowErrors e			-- fixed (finally!)
  :TexAlign			-- can manage table environments and also
				   join lines which do not end with \\, see
				   |g:atp_TexAlign_join_lines| how to set this.

  'iskeyword'			-- is set using g:tex_isk variable.  This is
				   compatible with the standard tex syntax
				   file.
  :TexAlign!			-- bang added+some fixes, see |atp-:TexAlign|.

								|atp-r|
  Replace()			-- if |g:atp_VimCompatible| is 0 then the
				   normal |r| will be overwritten with another
				   function with the following feature:
				   if you do |atp-r| over one of the brackets:
				   (:), {:}, [:] then r(, r{, r[ (and r), r},
				   r]) will change both: the opening and the
				   closing bracket.  Otherwise, i.e. over any
				   other character, or rc where c is other
				   than opening bracket at opening position or
				   closing bracket at closing position,
				   |atp-r| will work the same as |r|.

  New imaps:
  l*, L*	\wedge, \bigwedge (l = lattice theoretic, meet)
  l+, L+	\vee,	\bigvee   (join)
  wedge is also under #& but #ve (for \vee) and #V (for \bigvee) are removed,
  since they were interfering with #ve for \varepsilon.

  Greek Letter Maps: are disabled when the previous character is '\'.  So you
  can type '\#a' with the default value of |g:atp_imap_leader_1| and it will
  not transform into '\\alpha'.

  Toc:
  map _				-- set section: focus main window on the
				   section under cursor and jump back to Toc.
  map & vmap zc			-- fold sections/chapters/... .  Has one
				   limitation: cannot fold subsection if
				   section in which it sits is folded.
				   You can fold several sections at once using
				   visual mode (subsections will not be
				   folded in right way though).

>
 =====================
 Changes in version 10
<
  If you use <Shift-Tab> (i.e. non-expert mode for completion) to close
  a bracket, it will be put after the cursor, allowing you to write inside
  brackets.  This doesn't work with \(:\) and other math pairs and closing
  environments.

  Closing brackets with <Tab> is much faster now.

  cmap <M-c> ^\%([^%]\|\\%\)*	- useful when searching for sth which
				  is not in a commented out.

  Both vmap and imap for \overline and \underline are using
  |g:atp_imap_over_leader|.

  The value of |g:atp_MapSelectComment| is now |=c| (it used to be _c)
  You can also use v|ip| over commented lines to select them.

  New math imaps: (|atp-imaps-math|)
  |-	\vdash
  -|	\dashv
  ++ 	\sum	(it is disabled now when typing X_++ or X^++)

  The command :Align (and thus also :TexAlign) are using ATP_strlen function to
  measure the string length.  ATP sets g:Align_xstrlen="ATP_strlen" if
  'conceallevel' option is >0.  If 'conceallevel' is reset to 0 ATP_strlen
  behaves like g:Align_xstrlen=2. (This needs Align plugin version higher than
  36, available at: http://drchip.0sites.net/astronaut/vim/#ALIGN .

  |atp-:Toc| and |atp-:Labels| commands when open together will be in one
  column with table of contents at the top.

  ]*, ]%, [*, [%  - skip comment maps, all works now in the same way.  If 
  |g:atp_VimCompatible| is 1 they go to where comment starts/ends, if it is
  0 they go one line above/below. 

  cmap <M-c> will insert a pattern which match lines which are not a comment.


================================================================================
INSTALLATION                               		*atp-installation*

If you have .vmb (or .vba) file just open it in vim and source it (:so %<CR>).
You can also install ATP using Vim Addon Manager (VAM):
http://www.vim.org/scripts/script.php?script_id=2905
or GetLatestVimScipt plugin:
http://www.vim.org/scripts/script.php?script_id=642
Third option is to clone the git repository with the command: >
    git clone ssh://mszamotulski@atp-vim.git.sourceforge.net/gitroot/atp-vim/atp-vim ./atp
If you use VAM you can clone into your vim-addon directory
(~/.vim/vim-addons/AutomaticLaTexPlugin) and VAM will update it using git
pull.  In this way you will have always the most recent version of ATP.

Note: If you use Pathogen or VAM you need to restart all your vim servers if
you want revesre search to work, or at least use in each running server
pathogen#infect('addons'), or similar command with VAM (:ActivateAddons
AutomaticLatexPlugin).

     Necessary vim settings:
     |:filetype-plugin-on|
     |:filetype-indent-on|	(if you want to have automatic indentation for TeX files)
     |:syntax-enable|		(several features will not work properly without this option)

If you do not like colours you can still set syntax on but clear the highlight
colours (you should make a simple function which clears all the highlight
groups, because ':hi clear' will not give you what you want).

See |atp-requirements| for other ATP requirements or better go to:
http://atp-vim.sf.net/requirements.shtml web page.


GET ATP UPDATES ~
To get updates it is enough to use this command:
							*atp-:UpdateATP*
:UpdateATP[!]
	With bang update ATP to latest {UNSTABLE} snapshot, without to latest
	stable release.  It makes a check if your version is the latest one. 
	If you have installed {UNSTABLE} snapshot and then you run :UpdateATP
	without a bang "!", then ATP will ask you if you want to DOWNGRADE to
	the last stable release.

	{UNSTABLE} snapshots contain small fixes, and rarely, major changes
	of important parts of ATP (what can produce new bugs).  

	|atp-:UpdateATP| works well with pathogen vim plugin.

	Requires python (consult the |feature-list|).

							*atp-:ATPversion*
:ATPversion	
	This command prints version information of ATP and the time stamp when
	this version was build.  The time stamp is in format 'dd-mm-yy_HH-MM'.

--------------------------------------------------------------------------------
ATP ON WINDOWS							*atp-on-Windows*

The progress bar and callback features are turned off on Windows.  The reason
is how vim-server works on Windows: whenever one calls back it shows a window
with a message ERROR 0, which is quite annoying especially since compilation
script calls back vim several times.  ATP is not thoroughly tested on Windows
so feautures might not work.  Send me an email or write to the mailing list,
and note that its about ATP on Windows.

--------------------------------------------------------------------------------
ATP AND OTHER PLUGINS					*atp-and-other-plugins*
							*atp-EasyMotion*
EasyMotion and ATP ~
    If you want to use EasyMotion vim plugin (which is quite handy):
	http://www.vim.org/scripts/script.php?script_id=3526
    You can set |g:atp_Compare|="".  Alternatively, if you want to use the
    fastest comparing method of ATP, you can add to last line of
    s:EasyMotion() function (i.e. just above the |:endfunction| vimL keyword) in
    autoload/EasyMotion.vim: 
>
	    let b:atp_changedtick = b:changedtick
<   In older version of EasyMotion this function used to be inside
    plugin/EasyMotion.vim file.

    You might want to change g:EasyMotion_leader_key (see |easymotion-leader-key|), 
    because some maps of ATP are interfering with EasyMotion.  For example "-"
    might be a good choice.  You can also try to change |maplocalleader| which
    is heavily used by ATP.

================================================================================
COMMANDS	                               		*atp-commands* *atp-:*
							
							*atp-compilation*
The main function is not seen by the user (it is called s:compiler, for those
who want to read the plugin).  It executes tex compiler specified by the
variable |b:atp_TexCompiler|.  It is executed as an autocommand by the line: >
	au! CursorHold $HOME*.tex silent call 's:auTeX()'
< where s:auTeX() is a simple function which calls s:compiler if the file
written on the disk and the buffer differ.  There are two comparing mechanism,
the default one is using |b:changedtick-variable| , the seconds compares the
buffer with the on-disk version:
							*g:atp_Compare*
							*g:atp_compare_double_empty_lines*
							*g:atp_compare_embedded_comments*
	The default value is "changedtick".  Then the |b:changedtick-variable|
	is used to find if there buffer differs and to run latex.  With any other
	value a compare function will be used (which compares the buffer and
	the written file on the disk) - this method is much slower but has
	additional features: by default differences in comments are skipped
	(if you set |g:atp_compare_embedded_comments|=0 (the default is 1)
	then also the comments which do not start right at the beginning of
	line will be skipped).  The second feature is to not see differences in
	amount of blank lines: two or more blank lines is the same as one
	blank line, for this set |g:atp_compare_double_empty_lines|=0, which
	is the default.

As you can see it will run if a key is not pressed during time defined by
option |'updatetime'| (see |CursorHold|) in the normal mode.  If you type in
insert mode the file won't be compiled (and that's all right as you can be in the
middle of your very long formula).  The value of |'updatetime'| which works
fine is around 1000ms (|'updatetime'| is set in milliseconds).  Instead of
setting |'updatetime'| options directly you should set the variables
|b:atp_updatetime_insert| and |b:atp_updatetime_normal|.  Here's an important
note on using CTRL-C (|i_CTRL-C|) in Vim:

							*g:atp_IMapCC*
    In vim the key combination CTRL-C (|i_CTRL-C|) in insert mode exists to
    normal without triggering the InsertLeave autocommands.  In this way it
    doesn't changes the |'updatetime'| from |b:atp_updatetime_insert| to
    |b:atp_updatetime_normal|.  If |g:atp_IMapCC|=1 then |_CTRL-C| is mapped
    to |i_CTRL-[| so the InsertLeave autocommands are parsed.  However, it is
    a good habit to use |i_CTRL-C| while you are writing/editing and
    |i_CTRL-[| or |i_ESC| when you wish to see what you wrote (then TeX will
    be run quicker).  If you follow this you can even set
    |b:atp_updatetime_normal|=1 (if you set it to 0 then the file will not be
    processed while Vim is in normal mode).

							*b:atp_updatetime_insert*
							*b:atp_updatetime_normal*
>
 b:atp_updatetime_insert = 4000	
 b:atp_updatetime_normal = 2000
< - These variables sets the value of |'updatetime'| vim option.
    Separate settings are for normal and insert mode.  You can make
    |b:atp_updatetime_normal| even smaller so that the file is processed
    whenever you go out from insert mode to normal mode.  These values will
    overwrite the original value of |'updatetime'| (unless you set both
    variables to 0)  so you should adjust them in order for the change to have
    an effect.

    If you set |b:atp_updatetime_insert|=0 the TeX compiler will not be called
    while Vim is in the insert mode. 

    If you set |b:atp_updatetime_normal|=0 the TeX compiler will not be called
    while Vim is in the normal mode.

							*b:atp_MaxProcesses*
>
 b:atp_MaxProcesses = 3
<
    When |g:atp_Compiler|="python" this variable will control the maximal
    number of simultaneous LaTeX processes in the background.  If new process
    comes old and the number of processes is |b:atp_MaxProcesses| or bigger
    one appropriate number of processes is killed to have not more than
    |b:atp_MaxProcesses|.  If you set it to 0 ATP will not control the number
    of running instances of LaTeX compiler.  There is one more variable:

    							*b:atp_KillYoungest*
>
 b:atp_KillYoungest = 0
<
    When set to 0 (the default) oldest processes are killed, when set to
    1 youngest ones.  If your file is big it might be better to kill youngest
    processes.

Coming back to compilation ... ~

Tex compiler is run with one options:
	-output-directory 
which points to a unique temporary file in a temporary directory |b:atp_TempDir| 

							*b:atp_autex*
You can switch off/on the function s:auTeX by pressing <S-F5> or by letting
the local to buffer variable |b:atp_autex|=1 (on) |b:atp_autex|=0 (off).  It is
useful in some situations turn automatic compiling off. 
    Note: if you set |b:atp_autex|=2 the the automatic compilation will
    compile the currently edited subfile of your project (for this you need to
    use the subfiles package).
The key <S-F5> calls the command |atp-:ToggleAuTeX| which sets the variable
|b:atp_autex| and issue a message.  You can also set this variable to 0 for
some files that are not supposed to be processed, for example:
>
	au BufRead texmf/*.tex let b:atp_autex=0
<
On start up |b:atp_autex| is set to 1 if the path of opened file is not under any
tex directory ('kpsewhich -show-path tex', except the current dir).  For example,
files located under your local texmf tree will have b:atp_autex=0.  Also for
files with other extension than the standard "tex" it will be set to 0.

							*atp-:ToggleAuTeX*
:ToggleAuTeX {arg}
	The {arg} is one of off/on/local.  It sets b:atp_autex to 0/1/2
	respecively.  If {arg} is omitted it changes: local->off (2->0),
	on->off (1->0) and off->on (0->1).

The second important variable |b:atp_TexCompiler| configures if you use TeX,
PdfTeX, LaTeX, PdfLaTeX and it should point to the program name so please do
not use capital letters.

Next variable to set is |b:atp_OutDir|.  It configures where TeX
will put the output and where viewer and log analysing tools can find
appropriate files. 

The last top most important variable is |g:atp_keep| which is a list of extensions,
by default it is
    let g:atp_keep = [ "log", "aux", "toc", "bbl", "ind", "idx", "synctex.gz", 
		\ "blg", "loa", "toc", "lot", "lof", "thm", "out" ]
Files with this extension will be copied from |b:atp_OutDir| to the temporary
directory with appropriate name to be used when (La)TeX is compiling. (log file
will be only copied after it is created, other files will be copied back and
forth between you |b:atp_OutDir| and the temporary directory)

							*atp-compile.py*
There are two function compile which can compile your tex file: one written in
python (for portability reasons) and old one in bash.  They work almost the
same with one small difference.  The python code has some vim enhancements (for
example the progres bar).

The python code has a debug file compile.log under |g:atp_TempDir| will
contain all the errors issued by python, and 'compile.py.debug'
- debugging info printed by the |compile.py| script.

    							*g:atp_Compiler*
If for some reason you'd like to use the old 'bash' style script there is
a variable: >
	g:atp_Compiler = "python"
< just switch its value to "bash" (you don't need to restart vim).  OK, so
what is the difference: the python script uses psutil python library (probably
you need to install it, at least I had to.) It is for two purposes: to
determine if xpdf is running and secondly, more importantly to check if latex
is running. 
    							*b:atp_LatexPIDs*
The python script |compile.py| sends PID numbers of latex processes to vim
variable |b:atp_LatexPIDs|.  Then the function which makes the status line for
ATP has a python code to check if the latex PIDs are still valid processes.
This is more accurate than the method used with bash compiler (before running
latex increase variable |b:atp_running| and decrease after getting signal that
latex has ended).  In many situations this was failing.  The new method works
better, however it shows that latex is running after slightly longer period of
time (not that first python must run the script and then run latex). 

							*b:atp_TexReturnCode*	
The variable |b:atp_TexReturnCode| stores the return code of compilation.

See |atp-requirements-python| for python libraries that are used by ATP.

-------------------------------------------------------------------------------
CALL BACK AND DEBUG MODE				*atp-callback*
							*atp-debug-mode*
	By default the call back mechanism is turned on (g:atp_callback=1)

	When call back mechanism is set, which is by default if you run gui
	version, if you invoke 'vim' from command line you need to add
	'servername' variable, it might be desirable to alias Vim to to >
			vim --servername VIM 
< 	you have additional functionalities:
							*atp-signs*
							*g:atp_signs*
        * if you set |g:atp_signs| to 1 (the default is 0) call back and
	  |atp-:ShowErrors| will use |signs| to mark errors and warnings.

							*atp-status-line-notification*
							*g:atp_statusNotif*
	* Status Line Notification: status line can show if tex is running >
		let g:atp_statusNotif = 1
<	  If unset you will get a message when compiler ends.  If set the
	  number next to the name of your compiler indicates how many
	  instances are currently running.  If |g:atp_ProgressBar|=1 then also
	  progress information of TeX compiler will be shown.

	  It can also show if other programs such as bibtex, biber or makeidx
	  are curently running.
	
	* The log file will be automatically read after compilation (|:cgetfile|).
	  						*g:atp_cgetfile*
	  The command |:cgetfile| will be run when you open new files, this
	  nicely works with |:edit| command but not |:split| if you want to keep
	  the old log file in QuickFix window.  If this is the case set >
	     let g:atp_cgetfile = 0 
<   	  The default value is 1.	

	* Debug mode is set by the value of |t:atp_DebugMode|, you can set or
	  see its value using |atp-:DebugMode| command (with completion for
	  debug modes).
							*t:atp_DebugMode*	
							*atp-debug-mode-silent* *atp-debug-mode-autosilent*
							*atp-silent* *atp-autosilent*
	* if |t:atp_DebugMode| 	= 'silent' or 'autosilent'
	  :DebugMode silent
	  nmap <LocalLeader><LocalLeader>s
	       You will not get any message from compilation. 

	       In 'autosilent' mode the quick fix window will be automatically
	       closed if there are no more errors (this depend on error
	       format).

							*atp-debug-mode-debug* *atp-debug-mode-autodebug'
							*atp-debug* *atp-autodebug*
	* if |t:atp_DebugMode| 	= 'debug' or 'autodebug'
	  :DebugMode debug
	  nmap <LocalLeader><LocalLeader>d
	       After the end of compilation (invoked by the user or
	       autocommand) you will get a message with the return status of
	       the compilation.  If the exit code is non zero it will be
	       highlighted with |hl-ErrorMsg|.

	       If you open the error window with |:copen| or with the menu
	       option ToggleDebugMode then it will be automatically closed
	       after first compilation with no errors.  Quick fix window is
	       closed in both 'silent' and 'debug' debug modes.  This depends
	       on |errorformat| which you can set with |atp-:ErrorFormat|
	       and |atp-:ShowErrors|:
		    ATP test for 'no errors' is 'len(|getqflist()|)'.  If the
		    debug mode was 'debug' |t:atp_DebugMode| will fall back to
		    |g:atp_DefaultDebugMode| (by default it is the 'silent'
		    mode).

              The 'autodebug' works similar to 'autosilent' mode.

							*atp-debug-mode-Debug* *atp-debug-mode-autoDebug*
							*atp-Debug* *atp-autoDebug*
	* if |t:atp_DebugMode| 	= 'Debug' or 'autoDebug'
	  :DebugMode Debug
	  nmap <LocalLeader><LocalLeader>D
	       This mode is the same as 'debug' + after compilation ATP jumps
	       to first error.

	       The 'autoDebug' works similar to 'autosilent' mode.

							*atp-debug-mode-verbose*
							*atp-verbose*
							*b:atp_VerboseLatexInteractionMode*
	* if |t:atp_DebugMode| 	= 'verbose'
	       Every compilation which is invoked by the user will be run in
	       verbose mode (this mode is mapped to <F5> key).  In this mode
	       latex '-interaction=' switch is set from the variable
	       |b:atp_VerboseLatexInteractionMode| (the default value is
	       errorstopmode).

	Note: the 'verbose' mode in 'Vim' (in the console) needs to be run,
	when there is no other latex instance running.  Now you get a message
	to wait until compilation ends.  In future releases, a better solution
	will be worked out.  Gui version 'gvim' works better (as it doesn't
	suspend the editor).

	The background compilation is always done in |g:atp_DefaultDebugMode|.
	Unless it is set to 'verbose' in which case 'debug' mode is used. 


	See also |atp-:copen|.

      							*g:atp_ProgressBar*
>
 g:atp_ProgressBar = 1  
<       By default, when using the python compiler you will get progress 
	message in your status line.  The number indicates the last page number
	compiled by LaTeX.  If by some reason, you want to switch this off, set
	g:atp_ProgressBar to 0 (use |let|).

	You need |g:atp_statusNotif|=1 for this feature to work (if you use
	the status line provided by ATP).

	If there are many background processes the number which is shown
	belongs to the oldest process. (|g:atp_ProgressBarValues| is a dictionary
	{ 'pid' : 'pagenr' } - status line shows max of pagenr's).

	Note: the time between you start to compile and when [1] appears in
	the status line is mostly the time when LaTeX is reading all the
	packages loaded in the preamble.

	Limitations ~
	Progress Bar doesn't like when you switch windows while the
	compilation takes time.  You might need to use |atp-:Kill| command. 
>
 g:atp_ProgressBarValues
<	This is a dictionary of dictionaries:
	    { 'bufnr' : {dict}, ... }
	Every buffer gets its entry (by |bufnr()|).  The {dict} is a dictionary
	which is an empty dictionary {} if compilation is not going on, and
	while compilation it contains the dictionary of PID number and page
	number where the compilator actually is doining its job.

	Note: If you compile and the progress bar starts at page > 1, you can
	use 'let |g:atp_ProgressBarValues|={}' to reset the progress bar.  You
	should check if there is any LaTeX process running in the system.
	You can also use the |atp-:Kill| command which will reset the
	progress bar and kill the corresponding processes.

						    	*g:atp_DebugModeQuickFixHeight*
>
 g:atp_DebugModeQuickFixHeight = 8
<	This is the maximal height of |quickfix| window when opened by ATP.

	 						*atp-debug-mode-maps*
	 You can invoke compiler in the 'debug' mode with '|<LocalLeader>|d',
	 '|<LocalLeader>|D' for 'Debug' mode (jump to first error),
	 '|<LocalLeader>|l' uses the default mode.
	 						*g:atp_DefaultDebugMode*
>
 let g:atp_DefaultDebugMode = 'silent'
< 	This is the default debug mode in which background compilation will
	run.  It can be set to 'debug', setting it to 'verbose' will have the
	same effect as setting it to 'debug'.  ATP will come back to this debug
	mode if compilation ends with exit status 0.

	When compilations ends without errors (i.e. when quick fix list is
	empty for the current error format) |t:atp_DebugMode| falls back to
	|g:atp_DefaultDebugMode|.

							*g:atp_DebugCmdHeight*
							*g:atp_cmdheight*
>
 g:atp_DebugModeCmdHeight = &cmdheight
<       the default cmd height (see |cmdheight|) for the debug mode. 
	ATP will switch to it back and forth if needed.  By default it is set
	to |cmdheigh| value (thus unless you set it to sth else you will not
	see the difference). 

	When going out of debug/Debug modes cmdheight is set to
	|g:atp_cmdheight| value (with default value set from 'cmdheight'
	option on startup). 

	Note: if you change |cmdheight| you should also change
	|g:atp_DefaultCmdHeight|, unfortunately vim has not autocommand group
	event to do that automatically.


:DebugMode [debug-mode]					*atp-:DebugMode*
	Command which help to set |t:atp_DebugMode| variable (has completion).
	[debug-mode] is one of "silent", "debug", "Debug", "verbose" (they can
	be suppressed to 's', 'd', 'D' or 'v' (or "si"/"sil"/"sile"/... etc).
	If no argument is given it shows the current debug mode.

	:DebugMode[!] s[ilent]
	nmap <LocalLeader><LocalLeader>s
	:DebugMode[!] autos[ilent]
		It will load error file (|cgetfile|) with bang "!" it will
		open |quickfix| window if there are errors (|cwindow|).  If
		|quickfix| window was opened it will be closed.
		Sets |t:atp_DebugMode|='silent' ('autosilent').
	:DebugMode d[ebug]
	nmap <LocalLeader><LocalLeader>d
	:DebugMode[!] autod[ebug]
		It will load error file (|cgetfile|) and open |quickfix|
		window with |:copen|.
		Sets |t:atp_DebugMode|='debug' ('autodebug')
	:DebugMode D[ebug]
	nmap <LocalLeader><LocalLeader>D
	:DebugMode[!] autoD[ebug] 
		It will load error file (|cgetfile|) and open |quickfix|
		window with |:copen|.
		Sets |t:atp_DebugMode|='Debug' ('autoDebug')
	:DebugMode v[erbose]
		Sets |t:atp_DebugMode|='verbose'

	The height of the |quickfix| window will be one more than the length
	of quick fix list (|getqflist()|) but nor more than
	|g:atp_DebugModeQuickFixHeight|.
							
:copen							*atp-:copen*
	Works slightly different than |:copen|.  The [height] argument will not
	take effect.  Use |:resize| instead.  ATP computes the height of the
	QuickFix window, and uses the variable |g:atp_DebugModeQuickFixHeight|
	as an upper bound for QuickFix window height.

							*b:atp_ReloadOnError*
The variable b:atp_ReloadOnError if set to 1 (which is the default) reload the
file even when the exit status of compiler was non zero.  If set to 0, then the
file will not be reloaded [actually for viewers other than Xpdf it will not be
copied from the temporary directory, for Xpdf it will be copied but not
reloaded). 

There is also a variable which stores the last command which executed
your tex compiler, see |g:atp_TexCommand|.   

:[count]Tex[!] [debug_mode]				*atp-:Tex*
map [count]<LocalLeader>l, map [runs]<LocalLeader>d
	If anyway you want to run TeX yourself but you do not want to see the
	output this is the right tool.  This runs TeX in 'nonstopmode'.  You can
	specify an argument [count] which tells how many consecutive runs of
	TeX you need (this is important if you want to compile Table of
	Contents, or index, or the bibliography (see |atp-:Bibtex|)

	With bang it saves (using the |update| command) all loaded project
	buffers.

	If b:atp_OpenViewer=1 and there current viewer (b:Viewer) is not
	running on the output file then this function will open a viewer.
	By default b:atp_OpenViewer=0 and this feature is disabled. 

	The command :2Tex will call the compiler two times.

	It is useful when you want to make the outline (using hyperref
	package) of your article in pdf files, the tex file has to be
	'sourced' twice.  To make the bibliography you can use |atp-:Bibtex|.

	If {runs} > 5 it will be reduced to 5, to avoid running tex for hundreds
	(or event thousands) of times (what could happen otherwise by
	a mistake giving the range of the command to be the current line
	number).

	The optional argument [debug_mode] has possible values: '', 'silent',
	'debug', 'Debug', 'verbose'.  When '' the current debug mode is used
	(|t:atp_DebugMode|). ( [debug_mode] can be suppressed to 's', 'd',
	'D', 'v' or "si"/"sil"/"sile"/... etc.) See the description of
	|atp-debug-mode|.

	\d is mapped to :Tex debug and \l to :Tex (thus it uses your default
	debug mode).

:[count]Texl [debug_mode]					*atp-:Texl*
map [count]<LocalLeader>k
	This command compiles the current subfile (L - comes from "local") of
	the project (you have to use subfiles package). 

	This commands also sets 'errorfile' option (using |atp-:Tex| will set
	it back to the main log file).
	
	Note that ATP is coping the project aux file (if present) and using it
	for compilation of subfiles.  In this way you get all the labels and
	references.  If you add new labels to the subfile then ATP will copy
        the corresponding entries from the subfile aux file to the main aux
        file.  However, it will not work if the label (its value) was changed
        or removed.  Then you need to compile the project with |atp-:Tex|
        command.

	Note: the advantage of using subfiles package is that you
	can use |atp-:SyncTexl| command for forward searching in the local
	output.


:[count]Dtex 							*atp-:Dtex*
map [count]<LocalLeader>d 
	This is equivalent to ':Tex debug'.

:MakeLatex[!]						*atp-:MakeLatex*
	With one command you can make your whole document: cross references,
	bibliography (with or without bibtex), index, table of contents, table
	of figures, table of theorems ([ntheorem package]), table of
	algorithms. 

	With bang it saves (using the |update| command) all loaded project
	buffers.

	If aux or log files are loaded in a buffer then they will be deleted
	- this is a requirement of vimgrep internal grep command (other wise
	vimgrep will search in the buffer not the hard disk version and they
	may differ). 

	Returns with an error message if log contains '! Emergency stop.'

	If |g:atp_Compiler| = 'python' it uses the python script to compile
	document, if |g:atp_Compiler| = 'bash' it uses a bash command (UNIX
	only).

:Bibtex[!] [debug_mode]					*atp-:Bibtex*
map <LocalLeader>b
    With BANG "!":
	This function will call bibtex to produce the bibliography file
	(.bbl).  If in |b:atp_OutDir| there is no 'aux' file it first calls tex
	compiler.  After the 'bbl' file is produced two consecutive runs of tex
	compiler are called to make the bibliography.

	If you specify any value to the [debug_mode] option (for the values
	see |atp-:Tex|) In verbose mode (only the last time tex compiler will
	run in errorstop mode and echoed to the console).  This gives you the
	chance to see the output of bibtex command (it will be also printed
	when latex ends). 
	
	If bibtex returns with non zero exit code, latex will not be run
	afterwards. 
	
    Without BANG "!"
	If you want to just run bibtex use :Bibtex without
	bang.

	The command |atp-:Bibtex|  will :call Bibtex(), while :Bibtex v
	(and :Bibtex [debug_mode]) will :call Bibtex(1)

	The bang "!" is used in the same way as for |atp-:Tex| command.

	For the description of optional argument [debug_mode] see |atp-:Tex|.


							*g:atp_raw_bibinputs*
    Tex is looking for the date base files in the path: `kpsewhich -show-path
    bib`.  The variable g:atp_bibinputs contains these directories separated by
    commas.  If atp cannot find your bib file, tex also won't be able. 
							*g:atp_raw_texinputs*
    Similarly this variable stores all of path reported by `kpsewhich
    -show-path tex`.
							*g:atp_bibinputs*
    This is a list of directories as g:atp_raw_bibinputs with appended '**'
    see ':h file-searching'.
							*g:atp_texinputs*
    This is a list of directories as g:atp_raw_texinputs with appended '**'
    see ':h file-searching'.

    Note: The above four variables might be added to
    |g:atp_ProjectGlobalVariables|.  ATP will start faster, but remember to
    unlet them and restart vim when you change your TeX distribution, so that
    ATP will rebuild them.

							*atp-:Kill*
:Kill							
	Kill python scripts running (b:atp_PythonPIDs) and all pids in
	|b:atp_LatexPIDs|.  This only works with |g:atp_Compiler|="python".

:Pid 							*atp-:Pid*
	Prints PIDs of all running instances of |b:atp_TexCompiler|.


:Compiler {compiler-program}				*atp-:Compiler*
	Command which help to set |b:atp_TexCompiler| variable (with
	completion).

							*atp-:SetOutDir*
:SetOutDir [director]
	This is a command which sets the |b:atp_OutDir| variable to
	[directory] and updates the |'errorfile'| option.  If [directory] is
	not given it prints the current value of |b:atp_OutDir|.

							*atp-:Latexmk*
:Latexmk[!]
	Compile with latexmk in background. 
	With bang "!": Force compilation with latexmk in background.
	See |g:LatexBox_latexmk_options|.

							*atp-:LatexmkClean*
:LatexmkClean[!]
	Clean temporary output from LaTeX. 
	With bang "!": Clean temporary output from LaTeX.

							*atp-:LatexmkStop*
:LatexmkStop
	Stop latexmk if it is running.

							*atp-:LatexmkStatus*
:LatexmkStatus[!]
	Show the running status of latexmk for the current buffer. 
	With bang "!": show the running status of latexmk for all buffers with
	process group ID's.

:ShowErrors[!] [flag]					*atp-:ShowErrors*
nmap <LocalLeader>e					/for other maps see |atp-:ShowErrors-maps|/
	This command shows error/warning messages.  It sets the |'errorformat'|
	variable accordingly to the optional [flag] argument (if bang is used
	the change is permanent, if not |errorformat| will be restored at the
	end), which is a word made of letters:
>
		e		- include errors
		w		- include all warning messages
					(with g:atp_ParseLog, font warning messages are excluded)
		r		- include all reference warnings
		c		- include all citations warnings
		f		- include all font warnings
		fi		- include font info massages
		F		- show files listed in the log
				    (messages which start with 'File: ')
				    shows the files loaded by tex
				    for example fd files that LaTeX is using
		p		- show package info messages (g:atp_ParseLog only)
		P		- show packages loaded by tex 
				    (messages which start with 'Package: ')
		h		- show 'Overfull \hbox' and 'Underfull \hbox' messages (g:atp_ParseLog only)
		o		- open the log file in a new buffer (split).
		all		- all excluding f,fi,F,p,P
		All		- with g:atp_ParseLog:  show all the above,
				  with !g:atp_ParseLog: show whole log file.
<
	If none flag is given |g:atp_DefaultErrorFormat| value is used.  If
	'o' flag is used the split buffer with log message has a map 'q' to
	':bd'.  Example: >
		:ShowErrors rc
<	will show all reference and citation warnings.

	Note: this command works in quickfix window.  It will change
	errorformat but will not reload quickfix list.  Use |atp-:ErrorFormat|
	instead.

							*atp-:Cgetfile*
:Cgetfile	
	This works like |:cgetfile| command, but also filters errors from
	quick fix list which are not recognised by |errorformat| (it is done
	by |atp-:ShowErrors|).  This is only useful with |g:atp_ParseLog|=1 and
	when vim is not compiled with the patch 468, see |has-patch|
	(otherwise the command is not provided).  If you use cmdalias plugin
	(vimscript 746) you can alias this command to cg (|:cg|) in |atprc|
	file.

							*g:atp_ParseLog*
g:atp_ParseLog = 1
	If |g:atp_ParseLog| is 1 (|g:atp_Compiler|="python"), then ATP will
	parse the log file.  So that |quickfix| will show you corrent file
	names for the errors.  This is particullary usefull for project 
	files.  The new log file is written with an extension '_log'.

							*g:atp_DefaultErrorFormat*
g:atp_DefaultErrorFormat = 'erc' 
    The value is the  same as argument to |atp-:ShowErrors| and
    |atp-:ErrorFormat|.  This is the default argument for these commands when
    they are used without any argument.  Also corresponding 'errorformat' is
    set up at startup.
						 
							*b:atp_ErrorFormat*
b:atp_ErrorFormat = 'ecw'
	This variable stores the current format of errors.  It is a word with
	letters given in [flag] argument to |atp-:ShowErrors|.  You can set it
	with |atp-:ErrorFormat| command.  It is used by serveral ATP functions,
	for example call back feature checks if there are errors looking into
	Quick Fix list (with |getqflist()|), which will depend on the variable
	|b:atp_ErrorFormat|.
	    

ShowErrors maps:					*atp-:ShowErrors-maps* 

<LocalLeader>e		view errors with current |b:atp_ErrorFormat|	(:ShowErrors)
<F6>+e			to see all errors 			      (:ShowErrors e)
<F6>+w			to see all warnings			      (:ShowErrors w)
<F6>+r			to see warnings coming			      (:ShowErrors rc) 
			from references or citations  
<F6>+f			to see font warnings 			      (:ShowErrors f)

This is not a texloganalyzer mapping but it is a good place to mention it:
<F6>+l			to open log file in a new split window
			this is a mapping to the |atp-:OpenLog|.

:ErrorFormat {flag} 					*atp-:ErrorFormat*
	This command has the same syntax as |atp-:ShowErrors|.  It sets the
	|b:atp_ErrorFormat| variable and vim option |'erroformat'|, and the
	rereads the log file with |cgetfile|.  If {flag} is not given it only
	shows the current value of |b:atp_ErrorFormat|.  The variable
	|b:atp_ErrorFormat| is also set when you use the command
	|atp-:ShowErrors|.

	As an argument you may use +{flag} and -{flag} then {flag} will be
	added/removed from |b:atp_ErrorFormat|, example: >
		:ErrorFormat +w
		:ErrorFormat +w-f
		:ErrorFormat -F+e
<	will add 'w' to |b:atp_ErrorFormat|.		
	Note: this command works in quickfix window as well.

							*atp-:SetErrorFile*
:SetErrorFile					
	If you change |b:atp_OutDir| variable and you want to update the
	|'errorfile'| option use this command.  It will show you the value to
	which |'errorfile'| was set. 

:ShowErrors o						*atp-:OpenLog*
:OpenLog, map <F6>l, imap <F6>l
	Opens log file in a new split window with two options (which are set
	locally): 'ruler', 'nospell', and a map 'q' to ':bd'.	

	You can also use the command ':Explore' to see log, aux, ... files
	(which is a part of 'netrw' Vim plugin).


In the log file there are some special tools to syncronize the tex source file
and the Viewer (currently only Xpdf is supported) with log file:
|atp-:SyncTex| and |atp-:SyncXpdfLog|) These tools can sync tex file/Xpdf
automatically using autocommand group |CursorMoved|.

							*atp-:SyncTex-(log_file)*
:SyncTex[!]	(inside log file)
:nmap <LocalLeader>f, nmap <Enter>
	If you open log file with ':ShowErrors o' command then you can use
	this command to move to the place in the source code where the error
	occurs.  It works with project files and also can go to error which
	appear in a declared package.  It will go to the first error line
	declared in the log file below the cursor position (more precisely, to
	first line which matches '^l\.\d\+\|on input line\|at lines' will be used).

	With bang [!] it opens new window if the file with error is not shown
	in the current tab page.  Without bang it opens the file in the window
	where ':ShowErrors o' was used.
							*g:atp_LogSync*
	If you set |g:atp_LogSync|=1 (the default value is 0) then the source
	file will be syncronize with the log file via autocommand (with
	|CursorMoved|).  This sets 'cursorline' option to indicate the
	corresponding line in the source file.  When the log buffer becomes
	hidden this option should be unset.
							*atp-:LogSync*
	To set |g:atp_LogSync| you can use |atp-:Sync| command. |atp-:Sync|
	will toggle the value, ':Sync on' will set it to 1 and ':Sync off'
	will set it 
	to 0.

							*atp-:SyncXpdf*
							*g:atp_SyncXpdfLog*
:SyncXpdf
	If you set g:atp_SyncXpdfLog = 1 (the default value is 0) and you use
	Xpdf as a viewer it will be synchronised with the log file (with
	autocommand group |CursorMoved|).  You can also use the command
	:SyncXpdf or :Xpdf in the log buffer which does the same.

:View[!] 						*atp-:View*
map <LocalLeader>v, map <F3>, imap <F3>  
	You would like to see what you are editing use this function.  It will
	use the program defined in the variable b:atp_Viewer.  See |b:atp_Viewer|,
	|g:atp_XpdfServer|, |atp-xpdfOptions|.  When there is no output file it will run
	TeX and open the file.  Read more about particular viewers
	(inverse/reverse searching) in |atp-viewers|. 

	With bang (and <F3> maps) opens viewer at the cursor position in vim
	(forward search).  This will only work for viewers that support forward
	searching (xpdf, xdvi, okular, skim).

							*g:atp_OpenAndSyncSleepTime*
let |g:atp_OpenAndSyncSleepTime|="500m"
	Give 500 milliseconds for the viewer to read the file, before
	|atp-:View|! and |atp-:Viewl|! commands will do a forward search.

:ViewL[!]						*atp-:Viewl*
map <LocalLeader>V, map <S-F3>, imap <S-F3>  
	With this command you can view the subfile comiled by |atp-:Texl|
	command (or with |b:atp_autex|=2). "L" comes from "local".

	Bang and [i]map <S-F3> works as in |atp-:View|! command (and its <F3>
	map).

:SyncTex[!]						*atp-:SyncTex* *atp-\f*
map <LocalLeader>f, map <S-LeftMouse>
	Which makes an forward search (vim->Viewer).  As for now ATP supports
	Okular, Xpdf, Xdvi and zathura with this feature (Evince is not yet supported).

	With bang |atp-:SyncTex| will not check if the viewer is running.

	Note: you can also set reverse search for Okular, Xdvi and zathura see
	|atp-Viewers-Okular|, |atp-Viewers-Xdvi| and |atp-Viewers-zathura| for
	an instruction how to do that.  Xpdf doesn't support reverse
	searching.

							*atp-:SyncTex_Xpdf-hack*
	Note: there is a bug in Xpdf, one cannot sent commands to Xpdf to
	quickly.  If the |atp-:SyncTex| command only updates the page, but
	doesn't shift it then you can try to set g:atp_XpdfSleepTime variable
	to something higher than the default 0.1 (this is sleep time between
	sending commands to Xpdf in seconds)

	When the output file or the synctex file (.synctex.gz) doesn't exists
	then first it will be generated.  It can also open the document if it
	is not yet opened.

	Read |atp-:SyncTex_with_Okular| if you use Okular.

:SyncTexL[!]						*atp-:SyncTexl* *atp-\\f* *atp-\F*
map <LocalLeader>F
map <LocalLeader><LocalLeader>f
	Forward search from the subfile to its output (as compiled with
	|atp-:Texl| or |b:atp_autex|=2).

	With bang |atp-:SyncTexl| will not check if the viewer is running.



:Viewer {viewer-program}				 *atp-:Viewer*
    Command which help to set b:atp_Viewer variable (with nice completion).

:SetXdvi						*atp-:SetXdvi*
	This command sets the options for xdvi viewer, which enables inverse
	and reverse searching.  You can use the command |atp-:SyncTex| for
	forward searches (Vim->Xdvi) >
		:SyncTex	(although dvi is using srcspecials rather than synctex)
		map <LocalLeader>f
		nmap <S-LeftMouse>
<	For inverse searching hold CTRL and press click left mouse button on
	the text in xdvi viewer.  It sets: >
	    let b:atp_TexOptions="-src-specials"
<	and also other variable to enable reverse searching (Xdvi->Vim) see
	more |atp-viewers-Xdvi|.

	This command sets |g:atp_xdviOptions| variable, but do not overrides
	your settings if you defined '-editor' and '-watchfile' switches (it
	defines only these two, watch file makes xdvi reload the file every
	given interval)

:SetXpdf						*atp-:SetXpdf*
:SetOkular						*atp-SetOkular*
	This command sets options for Xpdf viewer.  Xpdf supports forward
	searching (vim->Xpdf) with command: |atp-:SyncTex|.  It sets >
	    let b:atp_TexOptions="-synctex=1"
< 	Thus it enables the forward searching (the above is the default 
	value for ATP, but it will change when you use |atp-:SetXdvi| which
	uses "-src-specials".

	It reads the Xpdf viewer options from the variables
	|b:atp_xpdfOptions| and g:atp_xpdfOptions.  Similarly for Okular.
						
							*atp-:PdfFonts*
:PdfFonts
nmap <F6>g
	Runs external program pdffonts on pdf output file.

:BibSearch /{pattern}/ [flag]				see |atp-:BibSearch|
	This function finds bib entries in bib files defined in your tex file
	and in the variable |b:atp_BibFiles|, which match the
	[pattern] (a Vim regular expression).  The output is configurable by
	the [flag] argument, see |atp-bibflags|.  By default the pattern is
	case insensitive.

							*atp-:AMSRef*
:AMSRef[!] {bibdata}  
    A command to get bib data from AMSRef:
		    http://www.ams.org/mathscinet-mref 
    The bib data will be appended to bibliography of the current document.  If
    there are many bib files will get a choice which one to use.  This command
    is also available in bib files.  Without bang, i.e. "!", it writes and
    closes the bib buffer with it will leave you in unsaved bib file buffer.
    You will be also asked for the bib key, the default choice is to use the
    AMS bib key. 

    							*g:atp_bibrefRegister*
    This command also works when you use \begin{bibliography} environment.
    But the default is to use a bib file.  The obtained bibliographic
    reference is copied to the register |g:atp_bibrefRegister| (the default is
    "0" so you can paste it using Vim command 'p').  In addition, it is stored
    in the variable g:atp_bibref.

:BibYank						see |atp-:BibYank|, |atp-:BibPaste|
map [count]c, [count]y, 
:BibPaste
map [count]p, [count]P
	This commands are defined in the buffer with results of
	|atp-:BibSearch| command.  It is mapped to '[count]y', '[count]c',
	'[count]p' and '[count]P' and let you copy the bib entry key to
	a register (see |atp-:BibYank|) or directly to the last opened buffer.

:FindBibFiles						*atp-:FindBibFiles*
	This updates the variables s:bibfiles, s:allbibfiles,
	s:notreadablebibfiles.  Finds all bib files defined in all
	'\bibliography' commands.  For more about the above variables read
	|atp-variables-bib|.  The command |atp-:FindBibFiles| finds bib files
	in the current buffer. 

	If a readable bib file was not found under one of path listed in of
	g:atp_bibinputs variable (see |g:atp_bibinputs|) it is classified
	as not readable.  
							
:GotoFile[!]						*atp-:GotoFile*
:Edit[!]				 		*atp-:Edit* *atp-gf*
nmap gf
	This command finds input files under b:atp_MainFile (it is recursive).
	The nmap 'gf' checks first if there is a file under the cursor.  If
	there is no file under the cursor it list all input files.  Input file
	is one introduced in the source file with \input{<file>}, \input
	<file> \include{<file>}.  The current file is now shown with highlight
	group: |hl-WarningMsg|. 

	This command uses kpsewhich to find in which path to find input files.
	Actually the path variables: |g:atp_texinputs| for input files and
	|g:atp_bibinputs| for bib files are used.

	The bibliographic declared are also listed.  The command searches for
	them in any directory listed in g:atp_bibinputs (see
	|g:atp_bibinputs|).

	If |g:atp_developer| = 1 (default 0) then the map 'gf' can also open
	package files and document class files, but only when using 'gf' over
	\usepackage, \documentclass, and \RequirePackage commands.

	With bang "!" this command regenerates tree of files (this is
	important only in files with input lines), without it uses cached
	values (if they exist).

	The current file is now shown with highlight group: |hl-WarningMsg|. 

:KpsewhichEdit {file}					*atp-:KpsewhichEdit*
	Find {file} using kpsewhich and edit it.  For example >
	    :KpsewhichEdit amsmath.sty
<
							*atp-:Texdoc*
:Texdoc
map <F1>, imap <F1>
	Then you have to type what you are looking for and press enter.  The
	option 'keywordprg' is set to 'texdoc -m', i.e when your cursor is
	over a package name and you press 'K' key then you should see the
	package document file (if it is named after the package).

	Without any argument it will open "g:atp_TeXdocDefault", by default it
	is equal to "-a lshort", i.e. "The not so short introduction to LaTeX
	2e" by Tobias Oetiker.  You can change the default for something that
	you use more often, for example you can set it to "-a faq", i.e. 'The
	UK TeX FAQ' (or even to "-a lshort faq" if you want them both :). 

							*atp-:Texdef*
:Texdef[!] {args}
	This command is an interface to the texdef program.  Use ':Texdef --help'
	to see the help message. |atp-:Texdef| command automatically sets the
	--tex switch (using |filetype|).  If run with bang [!] a comma
	separeted list of packages of the current tex file will be appended to
	the texdef command (using --package switch).

	Note: this command is defined only if |g:atp_developer| is set to 1 on
	startup.  See |g:atp_developer| for details.

							*atp-:InputFiles*
:InputFiles[!]				
	List input files of the current project.  It also updates the
	|b:ListOfFiles| and |b:TreeOfFiles| variables to the current values.

	The variable *g:atp_inputfile_pattern* is used as a pattern to find
	input files.  If you use 'biblatex' you do not need to put any pattern
	matching bibliographies (\addbibresource, \bibliography, ...), ATP has
	special way of dealing with them which is faster.  If you use 'subfile'
	package ATP will add \\subfile pattern.

	Without bang, i.e. "!", the commands also saves the data to the
	project script file |atp-ProjectScript|.  Adding "!" prevents this.

							*atp-:Open*
							*g:atp_LibraryPath*
:Open[!] [pattern] 
	If you configure g:atp_LibraryPath, this function will find files
	matching [pattern] under g:atp_LibraryPath and let them open with
	a program defined in >
		g:atp_OpenTypeDict
<	The g:atp_LibraryPath is a comma-separated list of directory names.
	You should use wild cards '**' and '*' as in |globpath()|, if you want
	to include subdirectories, etc.  For example >
	    let g:atp_LibraryPath=$HOME."/**"
<	will search for files under your $HOME directory.  The default value of
	g:atp_OpenTypeDict is: >
	    let g:atp_OpenTypeDict = { 
		\ "pdf" 	: "xpdf",		"ps" 	: "evince",
		\ "djvu" 	: "djview",		"txt" 	: "split" ,
		\ "tex"		: "edit",		"dvi"	: "xdvi -s 5" }
<	The values of g:atp_OpenTypeDict should be a program to open the file,
	or one of 'tabe', 'split', 'edit', (if 'vim' is specified, then 'tabe'
	will be used).  The cat program is also supported.

	Found files (all not just matching ones) are stored in the variable
	g:atp_Library.  It is set by |globpath()| on g:atp_LibraryPath and then
	filtered, only files which extensions are given in g:atp_OpenTypeDict
	will be stored.  This variable is restored by the global project script.
	You can use {bang} "!" to regenerate the library if it has changed.
	This is particularly useful as by default ATP remembers g:atp_Library in
	the common project script (see |atp-ProjectScript|).

							*atp-:Dictionary*
:Dictionary {word}
map =d
	This is an interface to http://www.impan.pl/Dictionary/.  Type a [word]
	and you will get quotes from mathematical articles or books written by
	native speakers of English.  The command has a completion for words
	List of words is hard coded in ATP (it is too slow to get it), since the
	dictionary evolves it might contain new entries (note: if this is the
	case, please inform me).

	The map takes the |<cword>| under the cursor as an argument.

:Delete[!]						*atp-:Delete*
map <F6>d
	Deletes all files which extension belongs to g:atp_tex_extensions in
	the directory |b:atp_OutDir|.  By default |g:atp_tex_extensions| does
	not contain 'tex', 'pdf', 'dvi' so none of your important files will
	be deleted.  When the command is used without bang the extensions
	from |g:atp_DeleteWithBang| are removed from |g:atp_tex_extensions|.
	The default value of |g:atp_DeleteWithBang| contains for example
	'synctex.gz' extensions, thus it won't be removed by :Delete (without
	bang "!").
							*g:atp_delete_output*
	If you set |g:atp_delete_output|=1 the function will delete also the
	current output file (but not any other!) and 'synctex.gz' file.

							*g:atp_DeleteWithBang*
>
 g:atp_DeleteWithBang = ['synctex.gz', 'tex.project.vim']
<	This is list of extensions which will not be removed when
	|atp-:Delete| is run without bang.  You do not need to add "pdf" or
	"dvi", extensions.

							*atp-:SshPrint*
:SshPrint [lpr_options]
	It will run 'lpr' command and append to it the options defined in the
	variable 'g:printeroptions' + options given in the second argument.
	It prints the pdf or dvi depending on the value of
	|b:atp_TexCompiler|.
							*g:atp_ssh*
	If you specify the variable 'g:atp_ssh=<user>@<host>' it will print
	via ssh on the <host> using the [lpr_options] passed to the lpr
	command.  The command ':SshPrint' has a completion set for the printers
	available on your local system or in the host.  You do not have to
	escape white spaces.
	
	The command has completion for the names of printers (also remote
	printers) and also other lpr options and its values, press <Tab> to
	cycle through printers, or type first letters of the printers name and
	press <Tab> to complete it.

							*atp-:Lpr*
:Lpr [lpr_options]					
	It prints using the lpr command on a local printer.  The syntax and
	completion are the same as for |atp-:SshPrint|.

							*atp-:Lpstat*
:Lpstat
	Sends "lpstat -l" remotely (using the |g:atp_ssh| value) or locally and
	echoes the output.

							*atp-:ListPrinters*
:ListPrinters
	List printers available on the host |g:atp_ssh|.

							*atp-:Wrap*
:Wrap [beginWrapper] [endWrapper] [cursor_pos] [new_lines]

	Puts selected text between [beginWrapper] and [endWrapper].  Also sets
	the cursor position according to the [cursor_pos].  Possible values
	are: a number -- indicates the character offset from beginning of
	[beginWrapper]; or "end" put the cursor at the end of [endWrapper] or
	"begin" leave the cursor at the beginning (to be precise at the end of
	the starting wrapper).  The default [beginWrapper] is '{', the default
	[endWrapper] is the bracket which closes the last character of
	[beginWrapper], if the penultimum element of [beginWrapper] is '\' it
	is also prepanded to the [endWrapper].  The last argument [new_lines]
	has two values 0/1 (default is 0): if 1 then the [beginWrapper] and
	[endWrapper] are put in separate lines (the begin line and end line
	are split), this is useful for putting text into an environment
	\begin{}:\end{}. 

	See |<f-args>| to know how to pass arguments. (They are separated with
	spaces, white spaces in arguments should be escaped with a backslash
	'\'.)

	For the predefined maps which use WrapSelection see below
	|atp-maps-WrapSelection| or use |atp-:HelpVMaps|.

							*atp-:Unwrap*
:Unwrap	
nmap <LocalLeader>u
	If cursor is standing over a bracket it will remove both matching
	brackets together with \left:\right, \bigl:\bigr, ... sizes.  This
	works for: (:), {:}, [:], \{:\}, \[:\] and \(:\).

							*atp-:IWrap*
:IWrap {mathWrapperPair}, {textWrapperPair}, [cursor_pos], [new_lines]

	Puts the selected text inside {mathWrapperPair} if the cursor stands
	in mathematics otherwise inside {textWrapperPair}.  {mathWrapperPair}
	{textWrapperPair} are Vim lists of length at least 1, the first
	wrapper is the opening and the second is the closing one (if not given
	the default '}' is used.  The other arguments are as for
	|atp-:Wrap|.  If the opening leader in is not given then this
	command is not wrapping the text (see below for the suggested map
	'\tx').

	The command arguments should be separated with commas and quoted
	separately (see |<args>|).

	For the predefined maps which use |atp-:Wrap| see below
	|atp-maps-InteligentWrapSelection| or use |atp-:HelpVMaps|.

	See section |atp-vmap-WrapSelection| on predefined set of vmaps.

	You can also use a wrapper which was yanked into register 'a': >
		:Wrap @a
<  	This will work not only in visual mode.  It will operate on last
	selected text.  So if you accidentally lost the selection you can still
	use this command (but not the maps)!

							*atp-:TexAlign*
:[range]TexAlign[!]
nmap <LocalLeader>a 
vmap <LocalLeader>a 
	This is a wrapper around Align command of the great AutoAlign Vim plugin:
	    http://www.vim.org/scripts/script.php?script_id=884. 
	This command sets correct align options and aligns the environment.
	The following LaTeX, AMSMath and Tikz environments are supported: >
	    align, alignat, array, displaymath, eqnarray, equation, flalign,
	    smallmatrix, split, tabular, table, longtable, \matrix (tikz)
<	Equation, align, alignat, flalign and displaymath are checked using
	syntax, tabular environment is checked using searchpair() function,
	the |g:atp_completion_limits|[2] applies.

	The command :Align (and thus also :TexAlign) are using ATP_strlen
	function to measure the string length.  ATP sets
	g:Align_xstrlen="ATP_strlen" if 'conceallevel' option is >0.  If
	'conceallevel' is reset to 0 ATP_strlen behaves like
	g:Align_xstrlen=2.

	With bang "!", |atp-:TexAlign| will join lines which do not ends with
	'\\'.  If *g:atp_TexAlign_join_lines* =1 then the map <LocalLeader>a
	will use the bang.

	When the [range] the lines in the range are aligned.  When [range] is
	specified then bang is not used (lines are not joined).  This also
	applies to the visual map.
    							*atp-:LatexTags*
							*atp-:Tags*
:Tags[!]
:LatexTags[!]
    Make a tag file with a python script included in ATP.  It also scans aux
    file for associated numbers to labels which then are used as tags.  If you
    declare hyperref package in the preambule also \hyperref{}{} commands are
    matched for tags as well. 
    |atp-:Tags| command will be defined only if you do not define it yourself. 

    Natbib as well as biblatex commands are supported (with exception of
    \cites, ... biblatex commands).

    With bang the bibtags for \cite commands are not made.  If you use more
    than one bibliography file searching to which of them it belongs might
    take some time.  If this is the case and you do not want this kind of tags
    you can make the tag file faster.

    Note: you might need to adjust 'iskeyword' Vim option.  ATP is adding
    |g:atp_separator| to 'iskeyword' if |g:atp_no_separator| is 0.

    Note!:In Vim 'iskeyword' by default contains '_'.  It is disabled by the
    standard tex syntax file (you do not want to include _ from _{} LaTeX
    construct into 'w' motion).  So it is better to avoid it in label names, so
    that |CTRL-]| works well.  If you need to add it use:
	au FileType set iskeyword+=_
    (this will not work with setlocal).

    Note: the python script is sourced in the background.  When the script
    finishes it will let you know.  The tag file is not accessible until the
    script finishes.

    Check out |tag-and-searches| how to use tags.

    :LatexTags command is only defined if there was :Tags command defined.

:Toc[!] 						*atp-:Toc*
nmap <LocalLeader>t
	Shows Table of Contents of your document.  It do not yet support the
	starred version of chapter, section,... . 

	The optional argument bang controls if the table of contents data base
	must be generated: by default map <LocalLeader>t doesn't regenerate
	the toc data base (unless if it doesn't exist), :Toc command
	regenerate the data base, :Toc! not.

	See |atp-toc-window| for commands and maps defined in the toc window.

	|atp-:Toc| supports many edited files.  The variable t:atp_toc_buflist
	is a list of project names (|b:atp_MainFile|) which are shown in ToC. 
	Use |atp-:RemoveFromToC| to remove a project from ToC. 

	If you have in your buffer list two files a.tex and b.tex this command
	will produce table of contents of both of them.  If you have just one
	opened window (excluding the ToC window) then pressing <space>,
	<enter>, p and _ will take you to the right buffer (which will be read
	if is unloaded or hidden).  If you split a window then <space>,
	<enter>, p, _ will take you to the window from which you are coming.
	However, if you have two windows with two different buffers loaded
	they will act on the window with the matching buffer name.

	The variable t:toc_window_width sets the width of table of contents
	window.  By default t:toc_window_width=30.  You can set a global
	variable g:toc_window_width to override the default value.

							*atp-:RemoveFromToC*
:RemoveFromToC {name}
	Remove the project with main file {name} from ToC.  There is
	a completion for {name}s.

*atplib#motion#ctoc()*
	This is a function which returns a list of section titles: >
	    [ chapter_title, section_title, subsection_title]
>	You can use it to show the current section in the statusline.

:Labels[!]						*atp-:Labels*
map <LocalLeader>L 
	Shows labels defined in your file.  You can also use the commands and
	mappings described in |atp-toc-window|.

	If you forget what are these mappings, write ':map <buffer>' in the
	toc or labels window, or move to the end of the LABELS window to see
	a short help message.

	The key 's' shows the context of the label under the cursor (your
	current window splits).

	The variable t:labels_window_width sets the width of labels window.  By
	default t:labels_window_width=30.  You can set a global
	variable g:labels_window_width to override the default value.

	Without bang "!" the labels data base will not be generated.
	Difference of \t and \L  is that \L regenerates the database (which is
	quite fast).

	Note: in memoir class you will not see labels type (in square
	brackets).

  							*atp-:GotoLabel*
:GotoLabel[!] {pattern} 
	The command does the obvious thing.  The {pattern} matches against the
	label or label value (as appears in output file).  When matching the
	label value '^' is added at the beginning of pattern.  With bang it
	doesn't regenerate the labels dictionary.  It works with project files.
	It has completion.  If pattern matches many labels they all are listed
	with some useful info: label value, label and the file where it was
	defined (only in projects).  Examples: >
	    :GotoLabel 1.2
	    :GotoLabel ^thm:
<       Note: there is |atp-:Tags| command which makes the tag file, and you
	can use vim |tags| commands.

	Note: You can also use a tag file and vim |tags| commands, see
	|atp-:Tags|.

							*atp-:GotoNamedDest*
							{only in Xpdf}
:GotoNamedDest <destination_name>
	Using '\hypertarget{<destination_name>}{<text>}' from hyperref package
	you can insert into PDF named destinations.  This command will set the
	position of PDF file in Xpdf to this destination.  There is
	a completion for destination names.  This command solely works with
	Xpdf.  Using: >
	    :%s/\\label{\([^}]*\)}/\hypertarget{\1}{}/gc
<       you can turned labels into named destinations.


							*atp-:F* *atp-]]*
:[count]F {arg}
nmap [count]]]
	Go (forward) to {arg}.  {arg} might be: part, section, subsection,
	subsubsection, defined environment name.  You can use command
	completion which uses all the locally defined environments.  It first
	check if there {arg} matches at the begining of any defined
	environment, if nothing is found it returns all the environments that
	match anywhere.  In this way you can do : >

	    :F oo<Tab>
<	and it should expand to >
	    :F proof
<
							*atp-:B* *atp-[[*
:[count]B {arg}
nmap [count][[
	Go backward to {arg}, the completion for {arg} works like for the
	command above: |atp-:F|.

							*atp-}m* *atp-}M*
							*atp-{m* *atp-{M*
nmap [count]]m [count]]M
nmap [count][m [count][M
	Got to next/previous math environment, with the captial M go to
	displayed math environment.

	If g:atp_mapNn is set to one (see |atp-:ToggleNn|) then this command
	is using |atp-:S|.

							*atp-%*
nmap %
	Jump to the matching pair (:), {:}, [:], \begin:\end.

 							*atp-}e* *atp-{e*
nmap [count]}e
nmap [count]{e
	Go to previous/next environment.  If the cursor is on the \begin the
	forward motion will not descent into child nodes (i.e. it will omitt
	environments inside).  The same applies to the backward motion. 

>
        \begin{theorem}
	        .....
		\begin{center} ◀――┐
		    ....          |
		    \begin{X}     |
                       ...        | }e, {e
		    \end{X}       |
		    ....          |
		\end{center>      |
		.....             |
		\begin{center} ◀――┘
		    ....
		\end{center>
		.....

<

	Note: the {e, motion when on a line with \begin will first move to the
	prvious \begin on this line and jump from there. 


	If you want to add |zz|, (|zt| or |zb|) after }e you can put this in
	your |atprc| file:
	    map <buffer> <silent> }e	<Plug>JumptoNextEnvironmentzz
	    map <buffer> <silent> {e	<Plug>JumptoPreviousEnvironmentzz

 							*atp-}E* *atp-{E*
nmap [count]}E
nmap [count]{E
	Go to previous/next environment one level up.  These are good motions
	when you want to go out of a nested environment, or jump to the \begin
	of the current environment.

>
        \begin{theorem} ◀―――――――――┐
	        .....             |
		\begin{center}    |
		    ....          | {E
		\end{center}      |
		.....          ―――┤
		\begin{center}    |
		    ....          |
		\end{center}      | }E 
		....              |
	\end{theorem}             |
	....                      |
	\begin{center} ◀――――――――――┘
	    ....
	\end{center>
<

	Note: the '\begin{' is not included as being inside, i.e. }E from
	above \begin will to the same place as being just before it (as on the
	above diagram).  This also applies to backward motions.  The
	environment name is treated as an interior part of the environment.

 							*atp-}o* *atp-{o*
nmap [count]}o
nmap [count]{o
        Go out of nested environments: |atp-}o| - forward; |atp-{o|
        - backward.

>
        \begin{document}

                \begin{center}◀――――――――――┐ 2{o        
		      ....               |
                    \begin{align} ◀――――――┤ {o
                           ....          |
                           ....       ―――┤
			   ....          |
                    \end{align} ◀――――――――┤ }o
		      ....               |
                \end{center} ◀―――――――――――┘ 2}o
            \end{theorem} 
	
<

 							*atp-}O* *atp-{O*
nmap }O
nmap {O
        Go out of all nested environments: |atp-}O| - forward; |atp-{O|
        - backward.

>
        \begin{document}

            \begin{theorem} ◀――――――――――――┐
                \begin{center}           |
                    \begin{align}        | {O
                        \begin{split}    |
                           ....       ―――┤
                        \end{split}      |
                    \end{align}          | }O
                \end{center}             |
            \end{theorem} ◀――――――――――――――┘
	
<

	Note: the motion is written using the |searchpair()| function.  Since
	it is slow on long files every call to |searchpair()| is limited to
	the scope of |g:atp_completion_limits|[3] ahead/back (it is computed
	for every call). 

							*atp-}f* *atp-{f*
							*atp-}F* *atp-{F*
nmap [count]}f [count]}F
nmap [count]{f [count]{F
	These two maps are only valid in beamer.  They goto next/previous
	frame.  |atp-}F| and |atp-{F| are using |zt| command.
						
							*atp-:NextSection*
							*atp-:NPart*	*atp-}p*
							*atp-:NChap*	*atp-}c*
							*atp-:NSec*	*atp-}s*
							*atp-:NSSec*	*atp-}S*
							*atp-:NSSSec*
:NPart[!], :NChap[!], :NSec[!], :NSSec[!], :NSSSec[!] [title_pattern]
[count]:F {section}
 map }p,  map }c,  map }s,  map }S
vmap }p, vmap }c, vmap }s, vmap }S

	Go to next part/chapter/section/subsection/subsubsection which title
	matches optionally given [title_pattern].  With bang "!" the command
	doesn't skip commented sections.  Maps skip them.  The search will wrap
	around the end of a file if 'wrapscan' is set.

	The {section} argument for :F is one off:
	    part/chapter/section/subsection/subsubsection.

	Map  		Command			Meaning
	}p		:NPart			go to next part
	}c		:NChap			go to next chapter
	}s		:NSec			go to next section	
	}S		:NSSec			go to next subsection

							*g:atp_map_forward_motion_leader*
	You can set the leader '}' using |g:atp_map_forward_motion_leader|
	variable.

	Note: If you set |g:atp_map_forward_motion_leader| to '>' then ATP remaps
	|>>| to >> and also |v_>| to >>.  |>| is working and is not touched by
	ATP.  If you have |'timeout'| set then the map is executed faster, if
	you use |'notimeout'| this workaround it makes these operators work.

	Note: If you set |g:atp_map_forward_motion_leader|="}" then ATP remaps |}|
	operator to }}.

	Note: if you set |g:atp_map_forward_motion_leader|="]" you might need
	to remap |]s| and |]c| (a good choice is to remap them to >S and >C
	only in normal mode, don't forget about |[s| and |[c|, you can also
	consider remapping >> to >> in normal mode - this is a setting the
	author is using).

	Note: the maps work in visual mode and operator pending mode ('d\ns'
	will delete till the end of the section).  You can use |n| and |N| Vim
	normal commands (also in visual mode) to go further. 

	In visual mode these maps go to end of current section or, if already
	at the end of section, end of next section. 

	[title_pattern] is the pattern which will match for the pattern, it
	should start with '.*' when you want to match somewhere in a middle of
	the title. 
	
	These commands (and maps) use Vim |search()| function or |atp-:S|
	command depending on the value of |g:atp_mapNn| (see |atp-:ToggleNn|,
	when g:atp_mapNn=1 the |atp-:S| command is used).  You can set the
	value of |g:atp_mapNn| using the command |atp-:ToggleNn|.  If
	'wrapscan' is set and g:atp_mapNn=1 the search will wrap around the
	end of the project (not the end of the current buffer).

	You can unmap these keys and use <Plug>GotoNextSubSection,
	<Plug>GotoNextSection, <Plug>GotoNextChapter, <Plug>GotoNextPart to
	define new maps.


							*atp-:PrevSection*
							*atp-:PPart*	*atp-[p*
							*atp-:PChap*	*atp-[c*
							*atp-:PSec*       *atp-[s*
							*atp-:PSSec*	*atp-[S*
							*atp-:PSSSec*
:PPart[!], :PChap[!], :PSec[!], :PSSec[!], :PSSSec[!] [title_pattern]
[count]:B {section}
 map {p,  map {c,  map {s,  map {S
vmap {p, vmap {c, vmap {s, vmap {S

	Go to previous part/chapter/section/subsection/subsubsection which
	title matches [title_pattern] (an optional argument).  With bang "!"
	the command doesn't skip commented sections.  Maps skip them.  The
	search will wrap around the beginning of a file if 'wrapscan' is set.

							*g:atp_map_backward_motion_leader*
	You can set the leader '{' using |g:atp_map_backward_motion_leader|
	variable.

	The {section} argument for :B is one off:
	    part/chapter/section/subsection/subsubsection.

	For description of arguments read |atp-:NextSection| just above.

	Map  		Command			Meaning
	{p		:PPart			go to previous part
	{c		:PChap			go to previous chapter
	{s		:PSec			go to previous section	
	{S		:PSSec			go to previous subsection

	These commands (and maps) use Vim |search()| function or |atp-:S|
	command depending on the value of |g:atp_mapNn| (see |atp-:ToggleNn|,
	when g:atp_mapNn=1 the |atp-:S| command is used).  If 'wrapscan' is
	set and g:atp_mapNn=1 the search will wrap around the beginning of the
	project (not the beginning of the current buffer).

	You can unmap these keys and use <Plug>GotoPreviousSubSection,
	<Plug>GotoPreviousSection, <Plug>GotoPreviousChapter,
	<Plug>GotoPreviousPart to define new maps.

	Note: If you set |g:atp_backward_motion_leader| as '<' then ATP remaps
	|<<| to << and also |v_<| to <<.  |<| is working and is not touched by
	ATP.  If you have |'timeout'| set then the map is executed faster, if
	you use |'notimeout'| this workaround it makes these operators work.

	Note: If you set |g:atp_backward_motion_leader|="{" then ATP remaps |}|
	operator to {{.


Previous commands where using relative position - goto next/previous
section/chapter.  The following commands/maps will go to section/chapter as
counted from first one.
							*atp-:SSec* *atp--S*
							*atp-:Sec*  *atp--s*
							*atp-:Chap* *atp--c*
							*atp-:Part* *atp--p*
:[count]SSec
nmap -S
:[count]Sec
nmap -s
:[count]Chap
nmap -c
:[count]Part
nmap -p
	Go to subsection/section/chapter/part [count] from begin of the
	section/chapter/document, i.e. 3]s will jump to section 3 in current
	chapter.  Mark ' is preserved.

	Note: if you are in a section which has no subsections :SSec and -S
	will go to next section, the same applies to other section types.

	You can set the leader for maps with *g:atp_goto_section_leader* .


    							*atp-:SkipCommentForward*
							*atp-]star* *atp-]%* *atp-gc*
:[count]SkipCommentForward 
nmap [count]]* [count]]% [count]gc
	Go to end of current/next comment group.  Do this [count] times.  The
	default [count] is 1.

	Note: if |g:atp_VimCompatible|=1 (the default) it goes one line below
	the last commented line, if it is 0 it goes to the end of the comment.

	Note: This commands wraps around the begining/end of the file.  The
	'wrapscan' option applies.
    							*atp-:SkipCommentBackward*
							*atp-[star* *atp-[%* *atp-gC*
:SkipCommentBackward 
nmap [* p% gC
	Go to beginning of current/previous comment group

	Note: if |g:atp_VimCompatible|=1 (the default) it goes one line above
	the last commented line, if it is 0 it goes to the begin of the comment.
							*atp-:ToggleStar*
:ToggleStar 	 	 
map |<LocalLeader>|s	  
	Add/removes a star from the current environment (if it is not one
	belonging to the list: >
		    g:atp_no_star_environments
<	See |b:atp_StarEnvDefault| and |b:atp_StarMathEnvDefault|.

							*atp-:InsertEnv*
:InsertEnv[!] {envname}
	This command inserts environment {envname} and puts the cursor at the
	end of \begin{{envname}} statement.  To open new line below use |o|.
	If used with bang the environment is inserted in line.

							*atp-:ToggleEnv*
:ToggleEnv	 	
map <S-F4>    		
	mapped to <F4> and <S-F4>, switches environment name.  See
	(i.e. echo ) g:atp_toggle_environments_1...7 (you can change or add
	your own variables, just add numbers - they must be consecutive).          	
	
	Read |g:atp_toggle_labels| below how it handles the prefixes of
	labels.

							*atp-:ChangeEnv*
:ChangeEnv		
nmap <F4>
	This does the same as the above command but asks for environment name

	Read |g:atp_toggle_labels| below how it handles the prefixes of
	labels.

							*g:atp_toggle_labels*
	The commands |atp-:ToggleEnv| and |atp-:ChangeEnv| changes the
	prefixes of labels (if there is one, which belongs to
	g:atp_shortnames_dict) and all ref's (\ref, \eqref and \pageref).  You
	have to turn on this feature by putting g:atp_toggle_labels=1 (by
	default it is 0).  If there is a label (\label{...}) to which it wants
	to change it doesn't change labels and issue a Warning Message but as
	this changes your file it is turned off by default.  It will still
	change the labels if there is a reference \(\ref{...}, \eqref{...},
	etc) (with undefined label).

	In project files this is done in all files belonging to the project.
	Changes are not saved by default (ATP uses |'hidden'| option, so when
	you use |q|! or |qa|! all changes will be lost).

							*atp-:ChangeLabel*
:ChangeLabel
	This command changes label in the current line and all its occurrences
	inside \ref{}, \pageref{}, \eqref{} commands. 

	In project files this is done in all files belonging to the project.
	Changes are not saved by default (ATP uses |'hidden'| option, so when
	you use |q|! or |qa|! all changes will be lost).
							*atp-:WrapEnvironment*
:WrapEnvironment {environment} 
vmap <F4>		
	Mark part of the text and wrap it into environment given as the
	argument, the map will let you choose the environment name.

							*atp-:Wdiff*
:Wdiff {old-file} {new-file}
	This is diff using the GNU wdiff.  This command will split the view and
	show the wdiff output.  You can use ]s and [s to go to next previous
	change.  The deleted parts of {old-file} are marked embraced into
	{=...=} and highlighted with |hl-DiffDelete|.  The added parts of
	{new-file} are embraced with {+...+} and highlighted with
	|hl-DiffAdd|.  If the preambles differ you will be asked which one to
	use in the diff file.

	This is an alternative for latexdiff program, but is much faster.

	The diff file might not compile well (thus the b:atp_autex is set to
	0 by default), this is mainly because the math environments can be
	break and the output might contain: \( a {= =c\)=} {+ !=c\)+} Other
	things which are not taken into account are changes of environment
	names, changes of coordinates in tikz.  It would be nice to tell to
	wdiff to not diff them, but this is not implemented.

	After you resolve such conflicts the file should compile nicely
	(though I didn't do many tests).  After that you can change {=...=}
	and {+...+} for something better.  For example you can change {= and
	=} for \textcolor{red}{=} and {+, +} for \textcolor{blue}{+}.  If you
	resolved syntactic conflicts in a very nice way you can change whole
	{=<old>=} for \textcolor{red}{<old>} and {+<new>+} for
	\textcolor{blue}{<new>}.  For this you can use the following Vim
	command:

							*atp-:NiceDiff*
:NiceDiff
	(which also remaps ]s and [s and keeps the highlighted areas).  The
	:NiceDiff command, although I tried, is not changing all the regions,
	I will try to fix this in next releases.  Thus not all parts of the
	output file might be highlighted.

							*atp-:Dsearch*
							*atp-[d* *atp-[D*
:Dsearch[!] [/]{pattern}[/] 					
nmap [d, [D
	The {pattern} argument is optional.  It is any vim pattern.  Finds all
	definitions which matches the pattern.  It looks in the main file
	(only in the preamble, unless the optional bang '!' is used) and all
	the input files (except bib files).  This command respects the options:
	'ignorecase' and 'smartcase'.  You can override them with '\C' (match
	case what follows) and '\c' (ignore case in what follows).

	The maps |atp-[d| and |atp-[D| are reading the keyword under the
	cursors (in the same way as |atp-gD| does), |atp-[D| uses the bang
	option of |atp-:Dsearch|.

	It works likes |[d|, |[D| but handles multi line definitions.  The
	also jump back to the current buffer, while the command leaves in the
	preview buffer.

	Recommendation: you can make command alias to |:ds| with cmdalias plugin
	(vimscript 746) in your |atprc| file.
							*atp-gD*
nmap gD
	This works like |gD| (with the difference that it searches in include
	files as well): it finds the first global definition of the command
	under the cursor.  It start from the first line of the main project
	file (|b:atp_MainFile|) and goes down visiting all included files on
	the way.  It finds definitions of commands, environments and colors.
	You can use |CTRL-O| to return.

							*g:atp_iskeyword*
	To get the keyword under the cursor, he 'iskeyword' is set to the
	value of |g:atp_iskeyword| variable.  By default it will only match
	[a-zA-Z] and the backslash.  At the end your 'iksyeword' setting will
	be restored.

	Note: to find environment the cursor have to be over the environment
	name rather than the '\begin' command.  If you want to go to the
	reference definition (\label) use |CTRL-]|, see |atp-:Tags|.

	Only available if vim is compiled with |+python| interface.

*g:atp_DsearchMaxWindowHeight* = 15
	You can set the maximal height of the window which shows the results of
	|atp-:Dsearch| (default is 15).

							*atp-:FontSearch*
:FontSearch[!] [pattern]				
	For example:
	:FontSearch ^t1
		will list all the fd files in your tex distribution which
		names starts with t1 (i.e. which describes fonts in encoding
		'T1')
	:FontSearch! bookman
		will list all fd files which full path matches 'bookman'.

	In the opened window there are several mappings defined:
	    <Enter>   	open the fd file under the cursor
	    <Tab>	list fonts defined in the fd file (shows the command
			that you can use in your tex file to use this font)
	    p		preview the fonts defined in the fd file under the
			cursor, do not shows the latex source. 	
	    P		preview fonts and show the latex source 
			(then you can see the errors why the preview was not
			produced; in many cases there are no encoding files or
			fonts themselves for which you have to look in CTAN
			archive yourself; or YOU CAN just SEE HOW TO USE 
			FONTS :) )
	    q 		close the window (actually, delete the buffer using
		       :bd, it will be still in the list if you type ":ls!",
		       so even then you can reload previous searches.)  

	In addition to 'p' and 'P' maps there is a :Preview command. 
	Note: the maps 'p' and 'P' work in both normal and visual mode.
	You can select a part of the text and use this maps or the command
	:Preview to make one preview file for all the font files.


	The same mappings are defined in the window with fd file opened
	(except <Enter>, <Tab>).  

	Additionally, read |font-lowlevelcommands| to learn how to use
	|\usefont|, |\fontsize|, |\selectfont| and other such commands.
	The 'Latex 2e font selection' by 'LeTeX3 Project Team' might be very
	useful.  It is available on the net (you probably have it in your tex
	distribution if it is installed with the documentation, if not check
	the CTAN archive).

	ATP also has a very nice completion for various font declaration
	commands, see |atp-completion-fontdeclaration|.

	Hopefully, this will help your documents to become beautiful :)

							*atp-:FontPreview*
:FontPreview[!] {fdFile} [encoding] [keep_tex]
	Previews all fonts defined in fd file matching the pattern <fd_file>
	with encoding [encoding] (optional).  If [keep_tex] is 1 (default is
	0) it will keep the latex source file for debugging purposes.

	Without [!] it matches just the name of the fd files, with [!] the
	pattern {fdFile} matches for full path.

	It returns a list of fonts which fd files matches the {fdFile} pattern in
	[encoding].  You will be asked to chose for which files make
	a preview, possible answers are: >
			1,2,3
< 	which is equivalent to >
			1-3
<	you can also mix this notation: >
			1,2-5,7	
<	As in FontSearch command the [keep_tex] variable specifies if
	the source file will be shown (for debugging purposes, or just to look how
	to use the font :).


							*atp-status-line*
:Status[!]						*atp-:Status*
(:ATPStatus[!])						*atp-:ATPStatus*
	This command sets the status line, which include: the name of currently
	edited chapter (or section) the value of |b:atp_OutDir| (unless used
	with bang "!") and it will warn you if |b:atp_OutDir| variable is not
	set.  Note: this command will set the variable |g:atp_statusOutDir|.
	The status line will also contain the information about processing
	compilation: see |atp-status-line-notification|, |g:atp_ProgressBar|.
							*g:atp_StatusLine*
	This command is called at startup unless the variable
	'|g:atp_StatusLine|=0'. 
<	
							*b:atp_StatusCurSection*
	If |b:atp_StatusCurSection| is set to 1 (the default) the current section will be
	put in the status line.  Some times it is slow though.

							*g:atp_statusOutDir*
	Note: if you set |g:atp_statusOutDir|=0 (the default is 1) then the
	output directory will be added to the statusline.  This variable
	only controls the status line at startup.  If you want to remove/add
	output directory rather use |atp-:Status| command.  The command
	respects the |'ruler'| vim option.

	If there is a command with name 'Status', ATP is not overwriting it,
	use :ATPStatus.

	Note: You can write your own status line.  There are three status line
	functions: >
	    atplib#ProgressBar()
	    atplib#StatusOutDir()
	    atplib#CurrentSection()
<	Note that you also need to set the variables |g:atp_ProgressBar|.  In
	this way you can turn off the progress bar temprarly.  The default ATP
	'statusline' value is something like this (so you can get inspired): >
	    let &l:statusline = '%<%f %{atplib#ProgressBar()}%= %{atplib#CurrentSection()} %{atplib#StatusOutDir()} %-14.16(%l,%c%V%)%P'
<	A good place to put your status line setting is
	'~/.vim/after/ftplugin/tex.vim' file.  If you set your own value of
	'statusline', don't forget to add |g:atp_StatusLine|=0 to your |vimrc|
	or |atprc| file.

ToDo({keyword}, {stop}, [bufname])			*atp-function-ToDo*
:ToDo[!] [bufname]					*atp-:ToDo*
:Note[!] [bufname]					*atp-:Note*
	The function list all the lines of the buffer [bufname] which match
	for the pattern '^\s*%.*{keyword}'.  The {stop} argument is the
	pattern to before which to stop.  The optional argument is the buffer
	name (the buffer name completion is set on).  If not given the current
	buffer is assumed.  You can set highlighting for this command by: >
		highlight atp-Todo ctermfg=... 	guifg=...
<	The command :ToDo sets keyword='^\s*%\s*$\|^\s*%\c.*\<note\>' and
	stop='^\s*%.*\c\<note\>', and the command :Note sets
	keyword='\c\<note\>' and stop='^\s*%\s*$\|^\s*%\c.*\<to\s*do\>'.  This
	prevent from listing ToDo lines with Notes and vice versa and stops at
	lines which contains only '%'.  With bang "!" the '^\s*' is not
	prepended to the patterns.

  							*atp-:WordCount*
:[range]WordCount[!]
	The command to compute the number of words.  With bang [!] it will show
	the word count of each input file.  It uses 'detex' program (which is
	present in 'texlive') to remove the latex markups prior to word
	counting (done by the external 'wc' program).  Note: This command will
	first save the file. 

	If [range] is not given (or is the current line) it counts words in
	whole file, otherwise counts words in the given range.

							*atp-:Babel*
							*g:atp_babel*
:Babel
	If |g:atp_babel| variable is set on start up to 1 (however, the default
	value is 0, you can use |vimrc| or |atprc| file to switch it on) then
	ATP will set the |'keymap'| option according to the default babel
	language (which is the last language passed to babel as optional
	argument [lang_list] in \usepackage[lang_list]{babel}). 
  
	If |g:atp_babel| is set to 1 the keymap name is shown in the status
	line (if you use the |atp-status-line|.
							*g:atp_keymaps*
	The |g:atp_kemaps| variable is used to translate babel language name
	to 'keymap' value.  The default is something like: >
    let g:atp_keymaps = { 
		\ 'british'	: 'ignore',		'english' 	: 'ignore',
		\ 'USenglish'	: 'ignore', 		'UKenglish'	: 'ignore',
		\ 'american'	: 'ignore',
	    	\ 'bulgarian' 	: 'bulgarian-bds', 	'croatian' 	: 'croatian',
		\ 'czech'	: 'czech',		'greek'		: 'greek',
		\ 'plutonikogreek': 'greek',		'hebrew'	: 'hebrew',
		\ 'russian' 	: 'russian-jcuken',	'serbian' 	: 'serbian',
		\ 'slovak' 	: 'slovak', 		'ukrainian' 	: 'ukrainian-jcuken',
		\ 'polish' 	: 'polish-slash' }
<	When the value is <ignore> then the function <SID>Babel() (or the
	command |atp-:Babel|) will ignore setting keymap option for this
	language.  Using the above syntax you can set this variable in |vimrc|
	or |atprc| file.

	This is useful if you in day to day work use one language, but some
	times you write a tex file in some other language.

							*atp-:ShowOptions* 
:ShowOptions[!] [pattern]
	This will show values of variables that are currently set. 
	With bang it also shows global variables defined in
	'ftplugin/ATP_files/options.vim' (that means almost all global
	variables).  Completion lists are filtered out by default. 

	The optional argument [pattern] is used to filter variables names with
	the given pattern.

	TIP: if you are looking for a variable you can use this command to
	find it.

							*atp-:HelpEnvIMaps*
							*atp-:HelpMathIMaps*
							*atp-:HelpVMaps*	
:HelpEnvIMaps
:HelpMathIMaps
:HelpVMaps
	These commands list valid mappings defined by ATP (unless g:no_plugin_maps or
	g:no_atp_maps are defined).

:Map[!]	 {pattern}					*atp-:Map*
:Nmap[!] {pattern}					*atp-:Nmap*
:Imap[!] {pattern}					*atp-:Imap*
:Smap[!] {pattern} 					*atp-:Smap*
:Vmap[!] {pattern}					*atp-:Vmap*
:Omap[!] {pattern}					*atp-:Omap*
:Lmap[!] {pattern}					*atp-:Lmap*
	The {pattern} is matched against the right hand side of a map as shown
	by the corresponding |:map| command.  If |<bang>| is added the pattern
	is matched against output of [nisvol]map commands with only first
	column removed (which indicates the map mode).

	The Imap can also find imaps which are not defined in normal mode
	(there are such maps in ATP), and thus are invisible while looking at
	the output of |:imap| command).
.

							*atp-:ShowPackages*
:ShowPackages	lists LaTeX packages defined in the preamble.
							*atp-:Preamble*
:Preamble	opens a scratch buffer with a preamble.  The buffer is not
		editable, unless the ViewPort plugin:
		    http://www.vim.org/scripts/script.php?script_id=4296
		is installed.
  							*atp-:ReloadATP*
:ReloadATP 
    Reloads ATP plugin: variables, functions, and maps.  Note that maps are not
    deleted.

================================================================================
							*atp-latex-box-settings-compilation*

Compilation ~

*atp-g:vim_program*			Default: autodetected

	Vim program to use on command line for callbacks.
	If autodetect fails, defaults to >
	'/Applications/MacVim.app/Contents/MacOS/Vim -g'
<	on MacVim, or to |v:progname| on other systems.

*atp-g:LatexBox_latexmk_options*	Default: ""

	Additional options to pass to latexmk during compilation, e.g, "-d".

*atp-g:LatexBox_output_type*	Default: "pdf"

	Extension of the output file.  One of "pdf", "dvi" or "ps".

*atp-g:LatexBox_autojump*		Default: 0

	Automatically jump to first error after calling latexmk.

================================================================================
TABLE OF CONTENTS WINDOW				*atp-toc-window*

	For the table of contents command and maps read |atp-:Toc|.

	The Table of Contents window is used by both |atp-:Toc| and |atp-:Labels|
	commands.

	In the Table of Contents window there are the following nmaps:

	    'e' 	to echo the line from your tex file
	    'y' or 'c' 	to yank the label of the chapter under the cursor
			    to a register, if it exists,
	    'p' 	to paste it directly to your tex file (just after the
			    current cursor position), 
	    '[N]s'	it splits the window with your tex source file and
			    sets the current line to the beginning of the
			    chapter/section or label under the cursor.
			    If [N] fiven the new window will be that heigh
			    (like with |:split| command).  In ToC window |zt|
			    is also used.
	    'q' 	to quit, 
	    <Enter> 	to go to the section under the cursor and close ToC.
   <space>, <LeftMouse> to go to the section under the cursor but
			leave ToC open.
	    '_' 	to go to the section under the cursor and return to 
			ToC afterwards.
	    'zc'	to fold section/chapter/... .  You can mark several
			lines in visual mode and use 'zc' to fold them at
			once. 
			Limitation: ~
			It cannot fold subsections in a right way when the
			section is folded.  In particular, this applies when
			folding several sections with subsections in visual
			mode.

	There are also commands: ':C' and ':P', which do the same as 'c' and
	'p' mappings.  They all call the function 'Yank(<where>)', the argument
	<where> can be one of: '@<register name>' or 'p'. 

	You can also delete and paste sections using the Table of Contents
	window:
							*atp-:YankSection*
							*atp-:DeleteSection*
							*atp-:PasteSection*
							*atp-:SectionStack*

	These commands are available in table of contents.  They act on
	parts/chapters/sections/subsections/subsubsections.
>
    :YankSection [register]
<	Yank the section under the cursor (in table of contents) to the given
	register.  If the register is not specified use the unnamed register
	(|registers|).
	 
	 The other commands do not use registers but an internal stack.
>
    :DeleteSection
    :PasteSection[!]
    :SectionStack
<	Using ':DeleteSection' you can delete the section under cursor together 
	with all its subsections.  Section can be one of: part, chapter,
	section, subsection, subsubsection, or bibliography.  Deleted section
	will be added to a stack which can be shown using the command
	':SectionStack' There is a command to paste the section from section
	stack ':PasteSection'.  By default it pastes the most recent element in
	the stack.  Passing a number will paste that element of the stack
	/bear in mind that then numbers of sections in the stack will change/.

	':PasteSection' puts the section just after where current section
	ends (section under the cursor in the ToC buffer).  With bang "!" it
	puts before.

	Note: If you use bibtex commands to make bibliography ATP finds the
	line which contains '\bibliography' command.  And then searches
	backward for the first line which is a blank line.  The next line is
	assumed to be the first line of bibliography.  Thus to move the last
	section before bibliography or the bibliography itself its better you
	put a blank line before bibliography commands.  The same applies for
	bibliographies put in the middle of document (end of a chapter, part,
	etc.)  The end of bibliography is found in the same way as the end of
	subsubsection.  If you use
	\begin{thebibliography}:\end{thebibliography} there is no such
	a problem.

	If you want to paste a section before the first section, use the line
	with the file name. 
							*atp-:Undo*
>
     :Undo 
     nnoremap u, nnoremap U, nnoremap g-, nnoremap g+ 
<	You can use undo.  The :Undo command will undo in the buffer under
	the cursor (it switches to the correct window, using the Vim undo
	function, and runs |atp-:Toc| command - so after all your back in ToC.).
	The ':Undo' command has one argument - the Vim undo command to use, it
	is one of: 'u/U/g-/g+' (the default is 'u').  They are mapped to
	'u','U', 'g-' and 'g+'.  (only in the ToC buffer).  Note: ':Undo'
	command doesn't changes the Section Stack.

	There is one more level of security: There is a global variable which
	stores all the deleted sections together with some information about
	them: >
			g:atp_SectionBackup
<	it is a Vim list (see |List|).  Each entry is a list of the following
	format: >
		[ <title>, <type>, <deleted_section>, <section_nr>, <file> ]
<	where <title> is the section title, <type> is one of: part, chapter, 
	section, subsection, subsubsection bibliography or abstract.  Deleted
	section is a list of deleted lines, <section_nr> is the number of the
	section that it had before delete, <file> is the full path to the
	file which it comes from.  If you need to use it, you can use the Vim
	function |append()| to put the <deleted_section> in the right place.

	NOTE:
		You may want to have a map: >
				:au FileType toc_atp nnoremap dd :DeleteSection<CR>
<		this can be put in your '$HOME/.atp.vim' configuration file.
			        			*atp-:Fold*
>
    :Fold, :'<,'>Fold
<	Fold section[s], works in the same way as 'zc' (as above) with the same
	limitations.


================================================================================
FOLDING							*atp-folding*
 I found a nice folding file (written by Johannes Zellner, added with his
 permission) there are two options:
 g:atp_folding = 0					*g:atp_folding*
	 enables/disables folding. you should set in your |vimrc| or |atprc|
	 files. if you reset the value on the fly you need to issue
	 '|:filetype| detect' command in order for changes to take place.

 g:atp_fold_environments = []			*g:atp_fold_environments*
	 enables/disables folding of environments.  By default folding is
	 disabled since it slows down vim.  The variable is a list of
	 environments which you want to be folded.  If you want to fold all
	 environments just set it to "['_all_']".
================================================================================
SEARCHING IN BIB FILES					*atp-bibsearch*

		___________________________
		Table of Contents: ~
		|atp-BibSearch|
		|atp-bibpatterns|
		|atp-bibflags|
			|atp-bibflags:default|
			|atp-bibsearch-show-only-keys|
			|atp-bibflags:+|
			|atp-bibflags:output|
			|atp-bibflags:all|
			|atp-bibflags:last|
			|atp-bibflags:add-flag|	
			|atp-bibflags:examples|
		|atp-:BibChoose|	
		|atp-bibsearch-highlight|
		|atp-:BibSearch|

		____________________________
		Naming Conventions: ~

		@article{<label>,					\	
			author = { .... },		<-- bib entry   | 
			title  = { .... },				 > bib field
			journal= " .... ",				|
		}							/	

			article 		<-- bib field keyword 
			author,title,...	<-- bib entry label 	
			<label>			<-- bib field label 	


One more function is provided which searches the bib files for bib fields, 
and for the bib field labels for the latex command \cite{}.

:BibSearch /{pattern}/ [flag] 				*atp-:BibSearch*
	which do what you expect.  The arguments should not be quoted and
	separated by a white spaces (if you want to include a white space use
	'\ '), for more see |f-args|.  If you do not provide any argument then
	all entries of all bib files will be shown. 
							*g:atp_bibsearch*
	Note: {pattern} should be a PYTHON regular expression not vim regular
	expression (they are similar to very magic vim expressions, see |\v|).
	Unless you set |g:atp_bibsearch|="vim" (the default is "python").
	Python regular expressions are quite similar to vim with 'nomagic' set
	( grouping with '(' and ')', with separating alternatives with '|').
	But there is no vim '\&' in python regexp.

	The pattern to highlight matching string is passed to |@/| hence you can
	use |n| and |N| in the BibSearch buffer.  This will only work for
	{pattern} which is both vim and python regular expression.

	See |atp-bibflags| for the [flag] argument.

							*atp-bibpatterns*
	Note: Upper pattern is vim pattern lower one is python regexp. 

	Before the match all the ligature symbols and {:} are removed.  For
	example \`a, \' e, \oa,\ea are substituted with a, e, oa, ea
	(respectively).  Note that the space in \' e is also removed.  Each
	line (without ligatures) of every bib file found in your tex document
	will be matched against the pattern, for example if the pattern is:
>
 		'author.*Grothendieck'
 		'author.*Grothendieck'
<
	the BibSearch function will find all the bibliographic fields
	which in one line have the words 'author' and 'Grothendieck' (in most
	cases it means that you will see only works of Grothendieck).  Another
	example:
>
		'^\(\s*author.*Joayl\)\|Galois Theory'
		'^(\s*author.*Joayl)|Galois Theory'
<
	will result in all bib fields which author is Joyal or 
	which includes the words 'Galois Theory' (which by the way appear in
	many article/book titles), yet another example:	
>
		'author.*Joayl\|title.*Galois Theory'
		'author.*Joayl|title.*Galois Theory'
<
	This will match against all bib entries written by Joyal or which title
	includes the word 'Galois Theory'.
>
 		'author.*Joyal\&.*Tirney'
		 ! python has no '\&' !
<	
	will find all the bib entries which were written by Joyal and Tirney
	(and maybe somebody else). 

	For now, there is no possibility to filter bibliographic entries which
	both match a pattern in separate lines, i.g. to show all bib entries
	written by Joyal on 'Descent Theory'.

	Before a match, all '{', and '}' are deleted from the line of the bib file.
	But you will see them in the output (what can be useful for debugging
	errors in bib files)

	Note that in Vim patterns should be quoted using '...' not "...".   

	Further examples are supplied after the next section
	|atp-bibflags:examples|, which describes other functionalities of the
	BibSearch/BibChoose commands.

							*atp-bibpattern:last*
							*atp-bib-b:atp_LastBibPattern*
	The variable 'b:atp_LastBibPattern' stores the last pattern used by
	bib search.

							*atp-bibflags*
	The optional argument [flags] chooses what and in which order you want
	to see the  bib entries found (entries are listed in the order they
	appear in bib file).  Flag is a word made of letters.  There are three
	kinds of flags: entry flags which matches against labels of bib
	entries, like author, title, etc..., and keyword flags: which matches
	against keywords of bib fields: @article, @book, @techreport, etc...
	and two special flags 'All' and 'L'.  A flag is a word on letters:
>
		a  - author
 		e  - editor
 		t  - title
 		b  - booktitle
 		j  - journal
 		s  - series
 		y  - year
 		n  - number
 		v  - volume
 		p  - pages
 		P  - Publisher
 		N  - Note
 		S  - School
 		h  - howpublished
 		o  - organization
		u  - url	
		H  - Homepage	
  any other letter - do not show anything but the first line of bib entry 
		@a - article 						/@article/
		@b - book or booklet 					/@book,@booklet/
		@B - Booklet 						/@booklet/	
		@c - incollection 					/@incollection,@inbook/
		@p - proceedings, inproceedings, conference   		/@proceedings,@inproceedings,@conference/
		@m - misc 						/@misc/
		@M - Manual 						/@manual/
		@t - master or PhD thesis  				/@masterthesis,@phdthesis/
		@T - Techreport 					/@techreport/
		@u - unpublished  					/@unpublished/		
		All - all flags						(see |atp-bibflags:all|)		
		L   - last flags					(see |atp-bibflags:last|)		
<
	Examples:
>
		tayu@a		--> show the entries: tile, author, year, url of matching articles.
		baeP@b		--> show the entries: booktitle, author, editor, 
 							publisher of matching books (@book,@booklet).
<
	Flags '@.' are filtered out, if one does not belong to the one above
	then it is deleted. Y ou can see which flags are defined using
	ShowOptions function/command (they are listed as Available
	KeyWordFlags).
							*atp-bibflags:default*
	The default flag is stored in the global variable g:defaultbibflags and is
	equal to 'tabejsyu'.  This means that the output for each bib field found 
	will include the 
		title
		author
		booktitle
		editor
		journal 
		series
		year
	if title,author,... are specified in the bibliography for the given
	position.  If there are many position which match you can set flags to
	be as simple as possible to include more lines on the screen.  For
	example 'tabe' is quite reasonable (note that all bib entries are
	matched separately, i.e. if a bib field has both 'title' and 'booktitle'
	bib entries it will give you both of them.

							*atp-bibsearch-show-only-keys*
	If you just want to list just the lines with bib fields keywords:
	@article{, @book{, etc. supply a flag which do not belongs to
	'g:defaultallbibflags', for example 'X', or 'X@a'
	
							*atp-bibflags:+*
	You can also specify flags with '+', for example: 
>
	flags='+p'
	flags='+@b'
<
	This feature ADDS FLAGS TO THE DEFAULT VALUE defined in the variable
	g:defaultbibflags (see |atp-defaulbibflags|).  The first will result in
	showing the default entries and the page number, the second will
	result in showing only books with the default bib entries.  You can
	specify as many additional flags as you wish.  *atp-bibflags:output*
	Note that the function shows the line with database file name if there
	are entries in this bibliography which match the pattern thus,for
	example, if you specify the flag '@a' and you see the line with
	database file name, but you do not see any bib entry, then in this
	database there are bib fields which match but these are not articles.
	
							*atp-bibflags:all*
	The flags='All' is a synonym of flag=g:defaultallbibflags which by default is
	equal to'tabejfsvnyPNSohiuHcp' i.e. all flags in this order.  If you
	add your own flag you should change this global variable.  You can add to
	this flag any flag which contains '@' (see |atp-bibflags|) by
	the plus operator, i.e.  All+@a@b or +@aAll will give the same result.

							*atp-bibflags:last*
							*atp-bib-b:atp_LastBibFlags*	
	The variable 'b:atp_LastBibFlags' stores the recently used flags.  The flag
	'L' sets the flags for this search to the value of 'b:atp_LastBibFlags'.
	You can write '+L@a', '+L@a', 'L@a' or '@aL' but not '+@La', if you
	want to add some flags to previous searches.  Next time the flag 'L'
	will change the meaning (i.e. it is really the last time not earlier
	:) However, there is no '-' :( '-@aL' could be helpful.
	 
	The variable 'b:atp_LastBibFlags' is not changed when you use the 'All'
	flag.

							*atp-bibflags:add-flag*
	You can add your own flags but not keyword flags (i.e. @a,@b,...).
	Just add an entry to the dictionary g:bibflagsdict. (:ShowOptions v to
	see its current value), For example
>
	let g:bibflagsdict=extend(g:bibflagsdict, 
	\ { '<flags_name>' : [ '<bib_entry_name>': '<how_to_show>'] })
< 
	where, <flags_name> is the flag to use (it should be one letter), it
	must be different from the defined flags, <bib_entry_name> is a
	lower case bib entry name, like 'title', 'url', etc., <how_to_show> if
	you want to have a nice output put the bib entry name and that much of
	white spaces to get 13 strings.

	Some examples:					*atp-bibflags:examples*
>
	    :BibSearch 
<				Above command shows all bib fields with
				the default flags (might be slow, why not to
				open bib file with :GotoFile)
>
	    :BibSearch @ yt	
<				and this is a tip how to show all bib fields with
				different flags than the default ones(the '@'
				will match at every bib field!).  It is
				equivalent to:
>
	    :BibSearch // yt

	    :BibSearch /title[\s.]*Galois Theory/  aetb
<
	The next one shows all bib fields which were written by Joyal and
	Tirney (and may by somebody else).
>
	    :BibSearch author.*Joyal\&.*Tirney
< 	This is not possible with |g:atp_bibsearch|="python" (the default).

		
:{BibEntry}Yank [RegisterName]				*atp-:Yank*
map {count[register]}c, map {count[register]}y
	This function/command is only available in the window with BibSearch
	results and allows to copy a bib entry key to a register or directly
	to the last opened buffer (after the cursor position).  It is mapped to
	'c' and 'y'.  You will be asked to give the number of bib entry to
	yank:
>
	    <bib entry number><register name><Enter>	- to copy it to a register
	    <bib entry number><Enter>			- to copy to the " register
	    <Enter>					- to skip the choice
<	When the {count} is given the bib item {count} will be copied to the
	register ".

	For example: >
		:5Yank e
		:7Yank +
		:2Yank
<	Copy the bibkey to register e,+, or " (this might depend on the
	'clipboard' option in which register the bib key will be put).  The
	same you will obtain using the nmaps y or c. 
	
	This commands and maps are only in the BibSearch buffer.

							*atp-:Paste*
:{BibEntry}Paste [RegisterName]
map {count}p, {count}P
	The syntax is the same as for |atp-:BibYank|.  It paste the bib entry
	to the tex buffer (where the |atp-:BibSearch| was inoked).  The bib
	entry is also copied to the " register.

							*atp-bibsearch-highlight*
	The colours of the output are set by the syntax file
	'syntax/bibsearch_atp.Vim'.  All groups except one are the same as in
	the syntax file for bib files ('syntax/bib.Vim' in your $VIMRUNTIME
	directory).  Their names are 'bibsearchEntryKw' instead 'bibEntryKw'.
	The one that is differently defined 'bibsearchComment'.  Which is
	changed in that way to highlight the bib file names.  One additional
	highlight group is: 'bibsearchInfo'.  It highlights the number of
	entry and its line number in the bib file.  By default all bibsearch
	groups are linked to the corresponding bib group, the bibsearchInfo
	group is not set.
	
	In a colour file (~/.Vim/color/*.Vim) you can use these groups to set
	colours.  See |highlight| or just read a colour file.  For example,
	this is a nice set of colours for dark background 
		
							 	
								
-----------------------------------------------------------------------------
BIBSEARCH COMMENTS					*atp-bibsearch-comments*	
					
	Please do not hesitate to report any bug to the mailing list
	|atp-mailing-list|.
	
	The algorithm will work only if all kind of bib entries of your bib
	file are included in the list g:bibentries.  However, changing just
	this variable is not enough.  In that case the search engine (function
	s:search) will produce correct output, but the function which displays
	found entries, will not know how to work with the new entries.  One
	would have to add an entry to the dictionary 'g:bibflagsdict'.  If
	it is the case, please let me know: |atp-mailing-list|.  

	As you can see entries of the type '@string' which can be used in bib
	files are not supported (i.e. there is no function which substitutes
	the variables defined in @string to their values), but it is doable.
			@string{ Name = Value }
			
================================================================================
COMPLETION			                        *atp-completion*

The completion is by default mapped to <C-X><C-O> (expert mode) and <C-X>o
(non expert mode).  However if you set |g:atp_tab_map| to 1 (in your |vimrc|
or |atprc| file), then  <Tab> (expert mode) and <S-Tab> (non expert mode) are
used.  For example if you type \math<C-X><C-o> you will get a list of choices
which completes this command. (See ':h popupmenu-completion' and ':h
completion' for more).

							*atp-completion-expert-mode*
							*atp-completion-non-expert-mode*
There are two completion algorithm: expert mode and non expert mode: the
keyword for completion in expert mode must match at the begining, in non
expert mode any where.  Also in expert mode the list of possible completions is
smaller (for example there is no '\lneqq', there is only '\lneq').

Note: Non expert mode doesn't check if you are editing math (see
|g:atp_MathOpened|), and is useful when you want to complete a non-math
command inside mathematics.

							*atp-tab-note*
							*g:atp_tab_map*
If you prefer to use map <Tab> key then you can define |g:atp_tab_map|=1 in
your |vimrc| file or atprc file |atprc|.  Note that Vim can add/remove
tabshift width from the beginning of line in other ways: in normal mode with
|>>| and |<<|, in insert mode: |i_CTRL-T|, |i_CTRL-D| and in visual mode with
|>| and |<|.  Also you can use |atp-g>| and |atp-g<|.  The alignment of tabular
and other environments can be done with |atp-:TexAlign| command. 


You can switch off/on completion modes adjusting the variable
|g:atp_completion_active_modes|, all names of completion modes are stored in
the variable |g:atp_completion_modes|.

							*g:atp_local_completion*
If |g:atp_local_completion| is set to non zero value, then input files will be
scanned for \def, \newcommand, \newnevironment and \newtheorem commands and
they will be used for completion (with |atp-:LocalCommands|).  If its value is
1 then this will be done during first completion, if it is set to 2 then this
will be done at start up.  The default value is 2 when vim has |+python|
feature otherwise it is 1.  With |+python| this is done at every time you
use the completion.

NOTE: if you press <C-X><C-O> but then you changed your mind, the completion
pop-up menu allows to cancel completion: press <C-p> (i.e.  go up - some
times more than once) and then press <Space>.

Note: The completion checks the preamble for definitions of LaTeX packages.
If a supported package is present (for example: tikz) then the completion will
contain additional commands.  If you add a package or a class you should unlet
corresponding variable: |g:atp_LatexPackages| and |g:atp_LatexClasses| and ATP
will regenerate them when necessary.

							*atp-:ToggleTab*
:ToggleTab			{only available if g:atp_tab_map=0}
nmap, imap `<Tab> 
    It is a command to toggle the tab map off/on: :ToggleTab, it is also mapped
    to `<Tab>. 
    Note: see |atp-Tab-note|.

DICTIONARIES ~
    I added extended versions of dictionaries of latex-suite to ATP (the files
    dictionaries/dictionary and dictionary/SIunits).  They are added to
    |'complete'| vim option, so you can use them through |ins-completion|.
    I made one more dictionary (dictionaries/ams_dictionary) with ams commands
    and environment names.  It will be added to the vim |'complete'| option if
    you use amsmath package or if the document class is one of the standard
    ams classes or of |g:atp_amsmath| is set to 1.

COMPLETION MODES		                       	*atp-completion-modes*
							*atp-completion-commands*
	commands ~
		if g:atp_check_if_math_mode = 1 then the pull of commands
		contains math commands only if there you are inside a math
		environment.  This works perfectly if you switch from $:$ and
		$$:$$ to their equivalent (and more up-to-date) \(:\) and \[:\].
		The list of math environment in which ATP will think you are
		editing a math mode is stored in the variable:
		'g:atp_math_modes'.  Its entries are two element list of
		patterns which matches the beginning and end of a math mode.
		The '0' entry have to provide the beginning and end pattern of
		in line math '\(:\)', the second for displayed math '\[:\]'.
		Its default value is given below.
	
		If you add a package (like tikz or amsmath, or amssymb) then
		the set of completions will contain extra commands/environment
		names defined in these packages  Because some classes calls
		amsmath package silently setting the variable
		'g:atp_amsmath=1' will ensure that you will get completions
		for these commands.  The algorithm checks if you have this
		package declared or if you use some of the standard ams
		class (actually checks if the document class name matches
		'^ams'). 

		If you do not want math commands completions at all define
		':let g:atp_no_math_command_completion=1' (you can put it in
		your |vimrc| or |atprc| file, or define while writing,
		both will work, so you can switch off the math completions
		temporarily).

		The label command completes in a special way: for example in
		a line like:
			\begin{theorem}\lab<Tab>
		will complete to 
			\begin{theorem}\label{thm:
		The dictionary of short names is 'g:atp_shortname_dict'.  If
		you do not likes this idea (however it can help you to
		correctly write \ref{ - to avoid referring to lemmas as
		propositions, and also it makes completion for \ref{ nicer
		- you can list only labels for theorems), so if you do not
		want it anyway: 'let g:atp_no_short_names=1' will make the
		work. 
							*g:atp_amsmath*
		If |g:atp_amsmath|=1 or you use one of ams classes, or the
		package amsmath is found by ATP ams math commands and
		environment names will be added to the list of completions.

							*atp-variables-local_completion*
							*b:atp_LocalColors*
							*b:atp_LocalCommands*
							*b:atp_LocalEnvironments*
		By default the first time you are completing an environment
		name or a command a list of locally defined environments and
		commands is made (it takes a few seconds).  If you do not want
		to completions for them define "let |g:atp_local_completion|=0",
		if |g:atp_local_completion|=2" then the search for local
		definitions and commands will be done on startup (after
		version 8.4 for this you have to switch off abbreviations by
		setting g:atp_noabbreviations to 1 - but anyway it is not time
		consuming because these variables are loaded from
		|atp-ProjectScript|).
							*atp-:LocalCommands*	
:LocalCommands[!]							
		If you added a command or an environment the command
		:LocalCommands! will update the list of local definitions.
		With bang "!" it update the list of input files
		|b:ListOfFiles| in which the search is done.  The output is
		stored in three variables: >
				b:atp_LocalColors
				b:atp_LocalCommands
				b:atp_LocalEnvironments
<		If a command was declared with a arguments (i.e. using \def#1, or
		\def#1#2, etc. or with \newcommand{...}[1]{...}) a single '{'
		is attached.  It doesn't match for definitions inside comments.

		This command will also make abbreviations to environments
		found, see |atp-abbreviations|.

		Note: the python version searches for commands, environments,
		...  defined in the beginning of line (with possible white
		spaces).

		Note: the python version of LocalCommands will save the
		current buffer, without saving project script and with
		'nowritebackup' and 'nobackup' set. 

							*atp-completion-tikzpicture*
	tikzpicture ~
		There is an extended support for tikz picture environment both
		in-line \tikz{:} and displayed: \begin{tikzpicture}
		\end{tikzpicture}.  The completion works for both commands and
		keywords.  The pull of them is enlarged if you add tikz
		libraries.  Normal commands are added if you are inside {:}.

		NOTE!: Keyword completion is only active in non expert mode
		(|atp-completion-non-expert-mode|).

							*atp-completion-ref*
							*atp-completion-label*
							*atp-completion-cite*
	ref/label/cite ~
		For label completion puts short names, for ref and eqref
		commands the completions are the labels found in all files
		associated to the main file (the plugin searches the input
		and include files for them).  The same for cite: which searches
		also in bib files defined in the main file.

		In the popup menu the first column show the label name, second
		column contains the first letter of the counter name used:
		e for equation, t for theorem, s for section, c for chapter,
		I for Item, etc. - these are the most common things you will
		see.  The third column contains the value of the counter.  It is
		put in brackets () if it comes from equation counter.

		There is also omni completion (see |i_CTRL-X_CTRL-O|) for
		\cite command.  Check it out, as it is very nice (especially in
		gvim!) and very fast. 

		For both completion and omni completion for the cite command,
		the text after \cite{  [ or after a comma after \cite{ ] is
		treated as a regular expression.  Thus you can write:

		\cite{.*author1\&.*author2<Tab>

		to get the completions for things written by both author 1 and
		2 (regardless of the order they appear in bib files).

		BibTeX omni completion is triggered by '\cite{', '\citep{' or
		'\citet{'.  For example, assume you have in your .bib files an
		entry looking like: >

		@book {	knuth1981,
				author = "Donald E. Knuth",
				title = "Seminumerical Algorithms",
				publisher = "Addison-Wesley",
				year = "1981" }

		Then, try: >

			\cite{Knuth 1981<CTRL-X><CTRL-O>
			\cite{algo<CTRL-X><CTRL-O>
<

		\ref{{pattern}<Tab> matches the label name for the {pattern}.
		When pattern is matched for a number of a label '^' is added in
		front of the pattern (see below).  In this case both
		completion modes: expert and non-expert works in the same way.

		You can also use Vim patterns after '\cite{'.

<		Tab Completion for labels (|atp-completion|) allows to specify
		the number of the counter, e.g. >
					\ref{3.1<Tab>
<		will complete into the label of the counter with value '3.1'.
		As for now you can not specify which counter to complete.  You
		can also write '\ref{3.1$' then '^3.1$' is used as a pattern!

		For this two work the aux file must be present.  As for now
		the aux file, if it is not present, is not made.

		This is working with the main document classes: article, book,
		review, amsart, amsbook, memoir.  If for some class it is not
		working thanks for reporting me (it's enough to email me just
		the document class).

							*atp-completion-brackets*
	brackets ~
		Closing of brackets {:},{:},[:],(:) (also closes math modes \(:\) and
		\[:\]). 
		Relevant variables are: g:atp_bracket_dict a dictionary of
		brackets by default it consists of pairs '(' : ')', '{' : '}',
		'[' : ']'.  There is a second dictionary g:atp_sizes_of_brackets
		which contains all the sizes of brackets in latex plus a pair
		'\' : '\', for closing the math modes: \(:\), \[:\] and the
		brackets \{:\}.
	
							*atp-closing-math*
							*atp-completion-math*
	math modes ~
		\(:\), \[:\], $:$ and $$:$$ will be closed when all brackets
		after the opening \(, \[, $ or $$ are closed.  If \[ or $$ is
		in line which matches '^\s*\(\\[\|\$\$\)\s*$' it will be
		closed in a following line.
							*atp-closing-environments*
							*atp-completion-env*
	environments ~
		Completes after '\begin{' and '\end{'.  For example
		'\begin{cen<Tab>' will give '\begin{center}' 
		But '\begin{theorem}<Tab>' or
		'\begin{theorem}\label{thm:1}<Tab> will close the environment.
		The algorithm tries to close environment in many natural
		situations: for example when it did found less than one command
		completion.  It closes the right environment when they are
		nested (however not in right place!) and it preserves the
		indention.  When after \begin{center}\label{...} XXX there is
		something (in place of XXX) it will close the environment
		after the cursor position otherwise in next line
		(\hypertarget{...}{...} command is treated like \lebl{...}).

		The environments opened in tex definitions ('\def',
		'\newcommand', '\renewcommand') will not be closed unless the
		current cursor position is in that line (sometimes one might
		want to have a definition which only opens an environment).

		If you type \begin{envname}<Tab> the cursor position will not
		change.  You can use |i_CTRL-M| (|i_CTRL-J| is used by
		|atp-j_motion|) after <Tab> to open new line inside {envname}.
		Otherwise the cursor position will be right after the closing
		\end{envname}.

		See |g:atp_amsmath|.

		Examples: ~
			(the <Tab> indicates in which position the
			<Tab> can be pressed to get the described
			behaviour).
>
			    \begin{theorem}
				    \begin{enumerate}
				    \item .....
				    \item .....
					\begin{minipage} 	
					    ......
					\end{minipage}
					    ......
					    ......<Tab>
					    XXXXXX
					    ......
			    \end{theorem}
<			Usually the closing comes in the next line,
			unless we are inside an environment which is opened
			after the non closed environment: 
>
			    \begin{theorem}
				    \begin{enumerate}
				    \item .....
				    \item .....
					\begin{minipage}<Tab> 	
					    ......<Tab>
					\end{minipage}<Tab>
					    XXXXXX
					    ......
					    ......
					    ......
			    \end{theorem}
<			Then the closing will be put just after the last
			opened environment closes, or
>
			    \begin{theorem}
				    \begin{enumerate}
				    \item .....
				    \item .....
					\begin{minipage}
					    ......
					\end{minipage}
					    ......
					    ......
					    ......
					    XXXXXX
			    \end{theorem}<Tab>
			    ....<Tab>
<			If we are outside the theorem environment,
			'\end{enumerate}' will be placed just above
			'\end{theorem}', and 	
>
			    \begin{theorem}[Joyal\&Tirney]\label{thm:jt}
				    \begin{enumerate}
				    \item .....
				    \item .....
					\begin{minipage} 	
					    ......
					    ......
					    XXXXXX
				    \end{enumerate}<Tab>
			    \end{theorem}<Tab>
<			will put \end{minipage} just above
			\begin{enumerate}.  Furthermore, if:
>
			    \begin{theorem}
				    \begin{enumerate}\label{enu:1}
				    \item .....
				    \item .....
					\begin{minipage} 	
					    ......
					    \begin{itemize}
						    ......
					    \end{itemize}
					    ......
					    ......
					    XXXXXX
				    \end{enumerate}<Tab>
			    \end{theorem}<Tab>
<			'\end{minipage}' will be put just above
			'\end{enumerate}'.  Furthermore,
>
			\begin{theorem}[...]\label{...} Let \(C\) be a ....
			......
			......<Tab> XXXXX
<	
		That is, if you like to write \begin{}:\end{} in the beginning
		and end of a line this will be preserved.  However, there is
		no support for nested environments then!

							*atp-completion-abbreviations*
	abbreviations ~
		There is tab completion for insert mode abbreviation names
		(use <CTRL-y> to choose one from the list and then type
		<space>, just typing <space> should also work).

							*atp-completion-fontdeclaration*
	font declarations ~
		This is completion for the commands 
		    \usefont{<encoding>}{<font_family>}{<font_series>}{<font_shape>},
		    \fontencoding{<encoding>},
		    \fontfamily{<font_family>},
		    \fontseries{<font_series>},
		    \fontshape{<font_shape>},
		    \DeclareFixedFont{<cmd>}{<encoding>}{<font_family>}{<font_series>}{<font_shape>}{<size>}
		
		It first splits the line and take a part between the commands
		\selectfont (if there is not \selectfont command this step is
		omitted).

		Then if the <encoding> is declared the font families for the
		completion will only come from this <encoding>.

		If <font_family> is defined, <font_series> and <font_shape>
		come from the particular font definition file (the declared
		encoding is used if not the value of
		|g:atp_font_encoding| is used).

		If <font_family> and <font_series> are defined then the
		<font_shape> for this font (in the above encoding) is found.

							*g:atp_completion_font_encodings*
		The completed <encoding>'s are taken from the variable:
		|g:atp_completion_font_encodings|.
		
							*atp-completion-bibstyle*
	bibstyle ~
		Completion for the command '\bibliographystyle{'.  Finds all
		"bst" files available in your tex distribution. 

							*atp-completion-documentclass*
	documentclass ~
		Completion for the command '\documentclass'.  Returns list of
		all classes available in your distribution.

							*atp-completion-documentclass-options*
							*atp-completion-package-options*
							*atp-completion-packages*
							*g:atp_packages*
	documentclass options ~
	package options ~
		The completion function only examins packages that are listed
		in |g:atp_packages| variables.  If you add a packages using
		completion it will be automatically added to the list,
		otherwise you have to add it manually: >
		    call add(g:atp_packages, 'wallpaper')
<

		You can write your own scrip which will add support for
		documentclass or a package (see |atp-copmletion-new-package|).
		This is only necessary if the buil-in ATP scanning method does
		not give all the commands that the package provides.

		Put it under 'ftplugin/ATP_files/packages/' directory in your
		vim path.  Supported variables:
>
	    g:atp_{dc_name}_options
	    g:atp_{p_name}_options
<		Note: ATP (if |+python|) scans package and documentclass files
		for options, so in general this variables are not needed.  The
		values in this variables will be added to completion.  They
		might be used if there are options which atp cannot find.
>
	    g:atp_{p_name}_commands
	    g:atp_{p_name}_math_commands
<		These are just list of options/commands.  The math_commands
		will be added to completion only in math mode.
>
	    g:atp_{p_name}_command_values_dict
<		This is a dictionary.  It is used to find completion for values
		of options of a given command: for example
		    \command{option=value}
		Each key is a pattern which will match against the command
		name.  The value is a dictionary which keys matchs for an
		option name and the corresponding entry is a list of possible
		values of the option. 
		(see ftplugin/ATP_files/packages/listings.vim)
>
	    g:atp_{p_name}_options_values
<		This variable is a vim dictionary: keys are vim patterns which
		should match a package option, values are lists of the option
		values.  See 'ftplugin/ATP_files/packages/caption.vim' for an
		example.  This was tested with the following option syntax: >
		    option1=value1,option2={value1,value2}
<		In a similar way works the variable: >
	    g:atp_{p_name}_command_values
<		See 'ftplugin/ATP_files/packages/enumitem.vim' for an example
		(or use ':echo g:atp_enumitem_command_values').
		or 'ftplugin/ATP_files/packages/xcolors.vim' 
		The value of a key in this dictionary might be a string, which
		is supposed to be a name of a function to get list of
		completions.  Afterwards this list will be filtered to get
		only matching completions.  It should return a vim list.  An
		example is in 'ftplugin/ATP_files/packages/xcolors.vim'.
>
	    g:atp_{p_name}_command_optional_values
<		As above but only for optional values like \includegraphics[...]
		See 'ftplugin/ATP_files/packages/graphicx.vim'.
>
	    g:atp_{p_name}_loading = { "package" : "option", ... }
<		This variable is a dictionary { "package" : "option" } which
		loads {p_name} package, when option is empty means that the
		package is always loading {p_name}.  Both "package" and
		"option" are vim patterns.  See packages/xcolor.vim for an
		example.  Loading through document class is not yet supported,
		but might be added on request.
>
	    g:atp_{p_name}_environment_options_values
<		This is a dictionary.  It is used to find completion for values
		of options of a given environment: for example
		    \begin{environment}[option=value]
		Each key is a pattern which will match against the environment
		name.  The value is a dictionary which keys matches for
		an option name and the corresponding entry is a list of
		possible values of the option.
		(see ftplugin/ATP_files/packages/listings.vim)


							*atp-completion-new-packages*
    ATP is scanning packages on the fly, i.e. there is a python script which
    scans package file for its options, commands and evironments that it
    defines.  This happens for packages that have a file under
    ftplugin/ATP_files/packages directory.  So if you want ATP to scan
    a package that you use it is enough to make an empty file under this
    directory with a name package.vim (e.g. listings.vim for listings.sty
    package).  You can (see other files in that directories) define list of
    options, commands, environments, etc and ATP is will add only the entries
    that you have missed (the reason for this is that when the package is
    updated in might have a new option/command/environment).

------------------------------------------------------------------
ATP COMPLETION VARIABLES				*atp-completion-variables*

These are all variables which can help to customise the completion:
(if the value is given it is the default, if it is not means it is too long to
put it here).
							*g:atp_completion_limits*
>
 	g:atp_completion_limits		= [ 40, 60, 80, 120, 30 ]
<
	    The above variable specifies how long should atp plugin search for
	    closed/unclosed environments:
	    the first value 	- search for \(:\)  [ in line math ]
	    the second	 	- search for \[:\]  [ displayed math ]
	    the third	 	- search for \begin{<env>:\end{<env>	
	    the fourth	 	- for environments defined in
				  the variable g:atp_long_environments
	    the fifth		- for checking brackets defined in
				  |g:atp_bracket_dict|.  You can speed up Tab
				  Completion by removing brackets that you
				  don't use from |g:atp_bracket_dict|.

	    You can also put "-1" as the values of |g:atp_completion_limits|,
	    then the search forward/backward will last till first/last line.
	    However, this makes it run slower.
							*g:atp_long_environments*
>
 	g:atp_long_environments 	= []
<	
	    If some of your environments are very long put their names in this
	    list.  Do not forget that is environment <env> is long and is put
	    inside environment <center> then <center> is also long!
				 
	    However, this will not close long environments (for that you have
	    to change the third argument of |g:atp_completion_limits| !).
	    This just prevents closing environments which are closed and to
	    long to see that.
							*g:atp_completion_modes*
>
  	g:atp_completion_modes		= [ 
				\ 'commands', 		'inline_math', 
				\ 'displayed_math', 	'package_names', 
				\ 'tikz_libraries', 	'environment_names', 
				\ 'close_environments' ,'labels', 
				\ 'bibitems', 		'input_files',
				\ 'bibfiles',		'bibstyles',
				\ 'documentclass' ] 	
<				
	    This is the list of completion modes.
							*g:atp_completion_active_modes*
>
	g:atp_completion_active_modes	= g:atp_completion_modes
<		This is the list of completion modes which are active, by
		default all modes are active.  Remove a value from this list
		to make it inactive (You can use remove() command, see ':h
		remove()'). 
>
	g:atp_sort_completion_list	= 12
<		If the length of completion list for Tab Completion is longer
		than this value, entries will be sorted alphabetically, else
		they are provided in, I hope, useful order.  If set to 0 the
		list will not be sorted (if set to 1 it will be always
		sorted). >
    	g:atp_environments
    	g:atp_amsmath_environments
    	g:atp_shortname_dict
<		It is used to define <short_name> in 
		    \label{<short_name><separator>
		when completing the \label command.
							*g:atp_separator*
>
    	g:atp_separator			= ':'
<		It is used as a separator in:
		    \label{<short_name><separator>
		when completing the \label command.
							*g:atp_no_separator*
							*g:atp_env_short_names*
							*g:atp_no_serparator_list*
>
    	g:atp_no_separator 		= 0
    	g:atp_no_separator_list		= ['', 'titlepage']
<		The following variable if set to one then completion for \label
		command will put short name of the environment where it stand.
		It uses the dictionary g:atp_shortname_dict to get the short
		name. >
    	g:atp_env_short_names 		= 1
<
							*g:atp_commands*
							*g:atp_math_commands*
							*g:atp_ams_negations*
							*g:atp_math_commands_non_expert_mode*
							*g:atp_ams_negations_non_expert_mode*
	These variables are lists which stores LaTeX commands used in
	completion. >
    	g:atp_commands
    	g:atp_math_commands
    	g:atp_ams_negations
    	g:atp_math_commands_non_expert_mode
    	g:atp_ams_negations_non_expert_mode
<			The two last are lists of commands will be add only in 
			the non expert mode (|atp-completion-non-expert-mode|).
>
    	g:atp_amsmath_commands
    	g:atp_fancyhdr_commands
    	g:atp_tikz_environments
    	g:atp_tikz_libraries
    	g:atp_tikz_commands
	g:atp_completion_truncate	= 4
		do not complete commands less than 4 characters (not counting
		the leading '\' if present).  If 0 then complete all the
		defined commands. This only works in the expert mode.

								*g:atp_MathOpened*
>
     	g:atp_MathOpened		= 1
<		the default value is 1.  With the default value expert mode
		completion will check if you are completing inside
		mathematical environment or not.  Inside math environment only
		math commands are completed and outside math commands are
		disabled.  This makes the set of completions more accurate.
		If you need non math command (like \textrm{}) inside math use
		non expert mode (see |atp-completion-non-expert-mode|)

								*g:atp_MathZones*
>
	let g:atp_MathZones	= [ 
	    		\ 'texMathZoneV', 	'texMathZoneW', 
	    		\ 'texMathZoneX', 	'texMathZoneY',
	    		\ 'texMathZoneA', 	'texMathZoneAS',
	    		\ 'texMathZoneB', 	'texMathZoneBS',
	    		\ 'texMathZoneC', 	'texMathZoneCS',
	    		\ 'texMathZoneD', 	'texMathZoneDS',
	    		\ 'texMathZoneE', 	'texMathZoneES',
	    		\ 'texMathZoneF', 	'texMathZoneFS',
	    		\ 'texMathZoneG', 	'texMathZoneGS',
	    		\ 'texMathZoneH', 	'texMathZoneHS',
	    		\ 'texMathZoneI', 	'texMathZoneIS',
	    		\ 'texMathZoneJ', 	'texMathZoneJS',
	    		\ 'texMathZoneK', 	'texMathZoneKS',
	    		\ 'texMathZoneL', 	'texMathZoneLS',
			\ 'texMathZoneT' ]
< 	the default value in plaintex files is >
	g:atp_MathZones	= [ 'plaintexMath' ] 
<		These are zones recognized by tab completion as mathematical
		ones (see |g:atp_MathOpened|).
>
	g:atp_tab_map
	g:atp_no_complete		= ['document']
<		List of environments which is not closed by <tab> completion.
		(The document environment in longer documents can be not seen
		by the algorithm as closed, because it searches only in a part
		of the text, see |g:atp_completion_limits| variable above).
>
	g:atp_bracket_dict 	= { '(' : ')', '{' : '}', '[' : ']', '<' : '>', 
		    \ '\lceil' : '\rceil', 	'\lfloor' : '\rfloor', 
		    \ '\langle' : '\rangle', 	'\lgroup' : '\rgroup' }
<		You can speed up Tab Completion by removing brackets that you
		don't use. >
	g:atp_sizes_of_brackets = {'\left': '\right', 		'\bigl' : '\bigr', 
				 \ '\Bigl' : '\Bigr', 		'\biggl' : '\biggr' , 
				 \ '\Biggl' : '\Biggr', 	'\' : '\' }
<
							*g:atp_LatexPackages*
							*g:atp_LatexClasses*
	The variables: >
	g:atp_LatexPackages
	g:atp_LatexClasses
<	stores list of packages and classes in your tex distribution.  They
	are restored when you exit Vim from the global project script (see
	|atp-ProjectScript_global|).  They are used for completion of the
	LaTeX commands \usepackage and \documentclass.

	If you reinstall, add or remove tex classes/packages from your tex
	distribution it is enough to unlet these variables.  ATP will find new
	values when it will need them for the first time. 


================================================================================
HOW TO CONFIGURE ATP TO YOUR NEEDS                      *atp-configure*
							*atp-variables*

There are several options you can set, and they might be set in your Vimrc
file.  The default values are given below (except the completion setup and
bibtex documented above).  Note: not all variables are listed below.

All the values of important variables with their values can be shown
(grepped) by |atp-:ShowOptions| command.

							*atprc*
$HOME/.atprc.vim (on Unix and GNU/Linux) or 
$HOME/_atprc.vim (on Windows)
$VIMRUNTIME/ftplugin/ATP_files/atprc.vim (only on MacOs and GNU/Linux)
    A configuration file for ATP.  You do not have to use autocommands to set
    local-buffer variables, just place them here.  The settings in |atprc|
    file override the values in the project script (|atp-ProjectScript|).  You
    can also overwrite the plugin maps there it you want to have different
    behaviour on the key map used by ATP.  This file is source twice, before
    and after sourcing ATP.

Tip: If you want to see (almost) all the variables, type ':let g:atp_<CTRL_D>',
and ':let b:atp_CTRL-d'.

All buffer variables (see |b:var|), i.e. these which name begins with "b:",
should be set in your |vimrc| or |atprc| file.  If you want to use your vimrc
file then the best way to do that is by using an autocommand:
>
	au BufReadPre *.tex let b:atp_TexCompiler="latex"
<
If you put just let |b:atp_TexCompiler|, this will also work but not always: for
example when you open a new buffer in existing Vim session.  However, if you
put them in your |atprc| it is enough to use the standard "let b:...=".
							*b:atp_TexCompiler*
>
 let b:atp_TexCompiler	= "pdflatex"			
<	Used by the command: |atp-:Tex| (map <LocalLeader>l, imap
	<LocalLeader>l, map <F5>, imap <F5>)

	You can set it to latex, tex, luatex, and so on and possibly to
	lilypond as well.  

	There is a command to set this variable with nice completion, see
	|atp-:Compiler|. 
							*b:atp_TexCompilerVariable*
>
 let b:atp_TexCompilerVariable = "max_print_line=2000" 	
<	You can use it to set an environment variables for the compiler.  The
	"max_print_line" sets the maximal length of a line in the log file.
	The value 2000 is high enough to prevent line breaking.

	Note: the grammar for this variable: it should be a semicolon separated
	list of variables and values, i.e. 'variable_1=value_1;variable_2=value_2'
							*b:atp_BibCompiler*
>
 let b:atp_BibCompiler	= "bibtex"			
<	This variable sets the bibtex backend.  There are other programs which
	might be used, for example biber and pybib (not tested with ATP).
	
	The default value will be "biber" if the preamule contains
	\usepackge[backend=biber]{biblatex}.  If it is set to "biber" ATP will
	adjust |g:atp_keep| variable (add run.xml, bcf extensions) when you use
	|atp-:Tex|, |atp-:Bibtex|, or |atp-:MakeLatex| commands.

	Biblatex package allows for putting \bibliography{} type commands only
	in the preamble.  Thus ATP will search for them only there.  The
	|g:atp_inputfile_pattern| might not contain any pattern for
	bibliographies (\addbibresource, \bibliography, etc.).  The
	|atp-:InputFiles| command will search for them in a special subroutine
	which only searches in the preamble.  This makes it slightly faster.

							*b:atp_TexFlavor*
>
 let b:atp_TexFlavor	= "tex"	
<	If you are editing a plain tex file it is automatically set to
	'plaintex', then you get highlighting for $$:$$.  Some other features
	are planned (you can also set this while editing a 'tex' file, i.e.
	latex document but using $$:$$ is latex is not recommended it is know
	to break some latex specific things).
							*b:atp_TexOptions*
>
 let b:atp_TexOptions	= "-synctex=1"			
<	This variable is a string of TeX compiler options separated by a comma. 
	If you want to set some additional options to your tex compiler you
	can use this variable, note that '-output-directory' and
	'-interaction' are set by ATP. 

							*b:atp_OutDir*
>
 let b:atp_OutDir	= fnameescape(fnamemodify(resolve(b:atp_MainFile,":h")) . "/"
<	This is the directory in which tex will put the output files.  If the
	open file is not a symbolic link it is equal to the directory in which
	the tex file is located.  If the open file is a symbolic link it points
	to the directory in which the real file is located. 
	
	If you set this variable to './' (or '.') and change the current
	working directory for example to /tmp (|:cd| /tmp) then the latex output
	will be placed in /tmp, i.e. it will move with with cd.  However, the
	default value of |b:atp_OutDir| is not affected by the |:cd| command.

	White spaces and other characters should not be escaped.  It will be
	quoted in '...' using the |shellescape()| function.

	You can see the current output directory in the status (it is in the
	short notation) to see it whole type:
		:echo b:atp_OutDir
	or use the |atp-:ShowOptions| command.		

	If in your environment the variable $TEXMFOUTDIR is set the value of
	|b:atp_OutDir| will be set to its value.

	If you reset this variable you also should reset the |errorfile| vim
	setting (or save the file - then |b:atp_OutDir| will be recorded in
	the |atp-ProjectScript|, and restart vim).

							*b:atp_auruns*
>
 let b:atp_auruns	= 1				
<	This variable control how many times the automatic function calls tex
	compiler (consecutively).  It is useful if you are working with PDF
	files and you want to have bookmarks (you can get them using hyperref
	package with the option: bookmarks.  Then set b:atp_auruns to '2'.

							*b:atp_running*
>
 b:atp_running						
<	This variable stores the current number of running instances of latex.
	When it is greater than 1 a message in the status line is shown.  If
	|atp-:Pid| command returns that no latex is running this variable this
	variable is reset to 0. 
							*g:atp_MathVimOptions*
>
 g:atp_MathVimOptions	= { 'textwidth' : [ 0, 78 ] }
<	This variable is a dictionary of Vim settings.  The value for each
	settings is a pair, where first value is the default used in math
	mode, and the second one used outside math environments.  For example,
	the default value will toggle between your 'textwidth' in non-math and
	0 in math.  The dictionary may contain short option names equally well
	as long names.

	Note: if you change the value of a setting which is in
	g:atp_MathVimOptions, only the non math value will be adopted.
			
							*g:atp_SetMathVimOptions*
	This feature can be turned off setting variable >
			g:atp_SetMathVimOptions
<	to '0', the default is '1'.
							*g:atp_autex_check_if_closed*
>
 let g:atp_autex_check_if_closed = 1  			
<	This feature is not implemented.
	tex run if all environments \begin:\end, \(:\) and \[:\] are closed.
	Set g:atp_autex_check_if_closed=0 in order to not make the checks.
							*g:texmf*
>
 let g:texmf	= substitute(system("kpsewhich -expand-var='$TEXMFHOME'"), '\n', '', 'g')
<	This variable configures where local input files are placed.  See
	|atp-:Edit|.  Note: if you set this variable in |vimrc| or |atprc| file
	vim will startup a bit faster with tex files, since calling kpsewhich
	is slow.
							*g:askforoutdir*
>
 let g:askforoutdir	= 0				
<	Its values are 1 and 0.  When it is set to 1 you will be asked for the
	name of a directory where tex will put output files, note that this
	name should end with a "/".
							*b:atp_Viewer*
>
 let b:atp_Viewer	= "okular"			
<	it was tested with Xpdf, Evince, ePdfViewer, Kpdf, Okular, Xdvi and
	they all works fine.  I'm using Xpdf and the Xpdf server options are
	supported so that the file is automatically reloaded (other viewers,
	except epdfview, have this functionality as well.  This do not works
	for acroread.  Read more about viewers in |atp-viewers|. 

	If you use program b:atp_Viewer then you can use the variable
	b:atp_{b:atp_Viewer}Options to set the options (it is a vim list), for
	example if b:atp_Viewer="xpdf" then you might use:

							*atp-Viewers_Options*
							*b:atp_xdviOptions*
    							*b:atp_xpdfOptions*
    							*b:atp_okularOptions*
    							*b:atp_evinceOptions*
    |b:atp_xpdfOptions|
    |b:atp_xdviOptions|
    |b:atp_okularOptions|
    |b:atp_evinceOptions|, etc ... (also global variables g:atp_...Options)
	Used by the |atp-:View| command (map <LocalLeader>v, map <F3>, imap
	<F3>)

	These are lists in which every viewer switch and its value should be
	placed as element (separate!).  See examples below. 

	For example, if you want to have different look of one document you can
	set it to "-bg gray20".  Some examples:
>
 	let b:atp_xpdfOptions	= ['-bg', 'Grey30', '-mattecolor', 'SlateBlue2', '-papercolor', 'White']
	let g:atp_xpdfOptions	= ['-bg', 'NavajoWhite4', '-fg', 'black', '-mattecolor', 'burlywood']
	let b:atp_xdviOptions	= ['-expertmode', '0', '-s', '6', '-watchfile', '1']
<	
							*g:atp_XpdfServer* 
>
 let b:atp_XpdfServer=fnamemodify(expand("%"),":t")		
<	This variables stores the name of Xpdf server (if you use xpdf to view
	pdf files).

	Used by the command |atp-:View| (map <LocalLeader>v, map <F3>, 
	imap <F3>) and also |atp-:SyncTex| (map <LocalLeader>f).

	You do not need escape spaces in the name (shellescape() function is
	used before it is send to the shell).
							*g:atp_LocalXpdfServer* 
>
 let b:atp_LocalXpdfServer=fnamemodify(expand("%"),":t")		
<	This variables stores the name of Xpdf server which will host compiled 
	subfiles.	
	
	Used by the command |atp-:Viewl| (map <LocalLeader>V, map <S-F3>, 
	imap <S-F3>) and also |atp-:SyncTexl| (map <LocalLeader>F).

	You do not need escape spaces in the name (shellescape() function is
	used before it is send to the shell).
							*b:atp_OpenViewer*	
>
 let b:atp_OpenViewer	= 1					
<	If the function which calls TeX compiler do not see that you are
	viewing the output file it will open it for you if b:atp_OpenViewer=1.
	Otherwise, this feature is disabled.
>
 let g:atp_delete_output	= 0
<	If set to 1 then Delete function (map <F6>d) will delete also the
	output file.	
							*g:atp_cpcmd*
>
 let g:atp_cpcmd		= "/bin/cp"
< 	This sets the copy command used by compiler.  The value tries to not use
	shell internal function and to avoid the -i switch (ask if overwrite). 

							*g:atp_tex_extensions*	
>
 let g:atp_tex_extensions=["aux", "log", "bbl", "blg", "bcf", "run.xml", "spl", "snm", "nav", "thm", "brf", "out", "toc", "mpx", "idx", "maf", "blg", "glo", "mtc[0-9]", "mtc1[0-9]", "pdfsync" , "ind"]	
<
	 This list is used by the |atp-:Delete| command which deletes all the
	 files with the specified extension in the directory |b:atp_OutDir|.
							*g:atp_keep*			
>
 let g:atp_keep	= [ "log", "aux", "toc", "bbl", "ind", "idx", "synctex.gz", "blg", "loa", "toc", "lot", "lof", "thm", "out" ]
<	Files with an extension belonging to this list will be copied from
	'b:atp_OutDir' to the temporary directory with appropriate name.  Then
	it will be used by (La)TeX. (log file will be copied after it is
	created, other files will be copied back and forth between
	'b:atp_OutDir' and the temporary directory).  These four elements:
	log,aux,toc,bbl are essentially minimum to work with: table of
	contents, pdf-bookmarks and bibtex.  There are possibly other classes,
	like beamer, or packages like theorem (produce .thm files) which will
	need to configure this variable.

	If you use "biber" ATP will add "run.xml" and "bcf".

	You can change this variable by the command:
		:let g:atp_keep+=["spl"]
							*g:printeroptions*		
>
 let g:printeroptions	= ""				
<	You can set the printer options.  These are options for the 'lpr'
	command, which will print the output file (pdf or dvi) this depends on
	the b:atp_TexCompiler that you use.
							*g:atp_TexCommand*
>
 g:atp_TexCommand						
<	This variable is for debugging purposes.  It stores the last executed
	command to compile your document. It changes also when your compiler
	was run automatically. >
		:Tex
		:echo g:atp_TexCommand
		:Tex!
		:echo g:atp_TexCommand
<	It is read-only variable.	
							*b:atp_TempDir*
>
 b:atp_TempDir = b:atp_OutDir/.tmp
<	In this directory vim (or python) will make a temporary directory
	(with a unique name) to which output files will be put by your TeX
	compiler.  This is done so to prevent overwriting the output file while
	the compilation is being done (this can cause problems when there are
	many TeX processes and the Viewer is accessing not yet compiled
	file).  The output files are copied back to b:atp_OutDir after
	compilation.  The temporary directory is passed to your TeX compiler
	using '-output-directory' switch.  

							*g:atp_TempDir*
>
 g:atp_TempDir 
<	In this directory the logs of ATP are stored.  If vim has python support
	is created by python in most secure way available (readable only by
	the user) if not it is made using |mkdir()| vim function with 0700
	permissions.

	Important Note: this directory is removed when Vim exists.
							*g:atp_CompilersDict*
>
 let g:atp_CompilersDict 	= { 
		\ "pdflatex"    : ".pdf", 	"pdftex" 	: ".pdf",
		\ "xetex" 	: ".pdf", 	"latex" 	: ".dvi", 
		\ "tex" 	: ".dvi",	"elatex"	: ".dvi",
		\ "etex"	: ".dvi", 	"luatex"	: ".pdf",
		\ "lualatex"	: ".pdf", 	"xelatex"	: ".pdf"}
<	This variable is used to associate an extension to the compiler that
	is used.


g:defaultbibflags		see |atp-bibflags:default|
g:defaultallbibflags		see |atp-bibflags:all|
b:atp_LastBibFlags		see |atp-bibflags:last|

b:bibfiles			see |atp-variables-bib|
s:bibfiles
s:allbibfiles
s:notreadablebibfiles
	For more on bib flags see |atp-bibflags|.
>
 let t:toc_window_width=g:atp_toc_window_width
<	t:toc_window with is set to g:atp_toc_window_width (by default is 30)
	The global variable configures the initial width of the window with
	table of contents.
>
 let t:labels_window_width=30
<	g:labels_window_width (by default not set, if set overrides
	t:labels_window_width)
	Configures the initial width of the window with labels.
>
 let b:atp_TruncateStatuSection=40
<	This variable sets how many characters of the section/subsection title
	(or chapter/section titles if you write a book) should be shown in the
	status line.  Section title and subsection title gets equal amount of
	characters.
>
 g:atp_kpsewhich_tex	
 g:atp_raw_kpsewhich_tex
<	This two variables stores the information returned by 
	    'kpsewhich -show-path tex'
	They are locked.  The first one has pretended '**' wild cards to every
	directory, which is done for using with globpath() and findfile()
	functions.

  							*g:atp_VimCompatible*
>
 g:atp_VimCompatible variable
<   	with default value 0 ("no").  Its values are 0/1 or yes/no.  It
	changes the behaviour of '%'. In nocomatible mode it goes to matching
	pair in a different line in compatible mode it finds the matching pair
	only if the ending bracket is in the same line.

	See also how it changes the behaviour of |atp-]%| and |atp-[%|.

	When the value is positive also do not remap the |r| (see |atp-r|)

							*g:atp_indent*
>
 g:atp_idnent=1
<	by defalt ATP is useing LatexBox indentation script.  If you set this
	to 0 the vim runtime indantation script will be used.  Also
	'indentkeys' differ.

							*g:atp_developer*
>
 g:atp_developer=0
<
	If set to 1 (the default is 0) then |atp-gf| can go to package and
	class files under texmf tree.  When set on startup within your |vimrc|
	or |atrc| file then also |atp-:Texdef| is defined (when set in |vimrc|
	file it be defined in any filetype - not only tex).

================================================================================
WRITING PROJECTS					*atp-ProjectFiles*
							*b:atp_MainFile*
>
 let b:atp_MainFile	= expand("%:p")
<	This variable points to the main file of the project, it is set on the
	start up to the file you open.  If you edit project file (for the first
	time), start with the main file and use gf (see |atp-gf|) to go to the
	project file you want to edit.  In this way all the project files will
	have correctly set this variable.  The value of this variable is used
	by compilation functions.  This variable is written in the project
	script (see |atp-ProjectScript|).  And when the project script is on (see
	|atp-ProjectScript|, or set |b:atp_ProjectScript|=1) it is restored between
	sessions.  In this way, next time, you can open any project file and
	the b:atp_MainFile variable will be set to the correct value.

							*b:TreeOfFiles*
							*b:ListOfFiles*
							*b:TypeDict*
							*b:LevelDict*
	The project feature stores more variables: |b:TreeOfFiles| a dictionary
	which contains the tree of input files, |b:ListOfFiles| - list of input
	files, |b:TypeDict| dictionary of types of input files, where the type
	is one of following: {preamble}, {input}, {bib}.  The last variable is
	|b:LevelDict| which is a dictionary of input levels (for example: an
	input file in input file has level 2).

	There are other tools to make editing project files more easy.  There
	is search function: |atp-:S| which works better than the Vim |:ijump|
	command, which cannot go above the current file in the tree of input
	files /but |:ijump| is much faster/. 

	If you write a project you might want to use subfiles package.  Then
	you can compile with |atp-:Texl|, view with |atp-:Viewl| and forward
	search with |atp-:SyncTexl|.  Furthermore, you can still use completion
	of labels by numbers if you add to the preambule of the subfile the
	following command (requires ifthen package): >
	    \ifthenelse{\value{chapter}=0}{\setcounter{chapter}{CHAPTER_NR}}{}
<	This command will manually set the chapter number to CHAPTER_NR.
	However, when you compile the whole project this command will not
	affect the project.

*b:atp_ProjectDir*
	Stores the project directory, by default where |b:atp_MainFile| is
	located (the filename is resolved if it is a symbolic link).  It is not
	written to the |atp-ProjectScript| (this makes the |atp-ProjectScript|
	independent of the host when |g:atp_RelativePath| is set).  This
	variable is mainly for internal purposes.  If you want to set the
	output directory use |b:atp_OutDir|.

*g:atp_RelativePath*
	If set to 1 (which is the default), project variables: |b:atp_MainFile|,
	|b:TreeOfFiles|, |b:ListOfFiles|, |b:TypeDict|, |b:LevelDict| will store path
	relative to |b:atp_ProjectDir| (which is the same as path to your main
	file, however if the file is a symbolic link it will hint to the
	resolved path).  The |atp-:S| will use correctly these values.  This is
	particularly useful if you want to share the project file.
	 
	If you run into problems with |atp-:S| you can set this variable to
	0 and use |atp-:InputFiles| to regenerate the variables - they will
	now store the full path (the other way around also works).

:ToggleNn [on]						*atp-:ToggleNn*
	The command |atp-:ToggleNn| toggles the value of |g:atp_mapNn| variable.
	The optional argument [on] has three possible values: "",  "on" or
	"off".  The default "", toggles the value of |g:atp_mapNn|, "on" sets
	g:atp_mapNn to 1 and "off" sets it to 0.
							*g:atp_mapNn*
>
 g:atp_mapNn = 0
<	If it is set to 1 then several tools use |atp-:S| command instead of
	Vim |search()| function (which looks only in the current buffer).
	These are: 
	|atp-:NPart|, |atp-:NChap|, |atp-:NSec|, |atp-:NSSec|, |atp-:NSSSec|, 
	|atp-:PPart|, |atp-:PChap|, |atp-:PSec|, |atp-:PSSec|, |atp-:PSSSec|.

	The default value of |g:atp_mapNn| is 0.

	The variable g:atp_mapNn should be always set as follows (in
	|atprc| or |vimrc| file): >
		if !exists("g:atp_mapNn")	
		    let g:atp_mapNn = 1
		endif
<	Then the value will be preserved when atp opens new buffer 
	when using |atp-:S| command.  If you want to have project specific
	setting use |atp-ProjectScript|.

	Another good tip for LaTeX project files is to set |b:atp_TexFlavor|
	variable to 'tex' (in your |vimrc| or |atprc| file).  This will prevent
	from situations that Vim recognizes input file as a plain TeX while it
	is an input file into a LaTeX project. 
	Another way is add options to 'viewoptions' (see |'viewoptions'|).  And
	set mkview and loadview via autocommands >
		au BufWinLeave *.tex mkview
		au BufWinEnter *.tex silent loadview
<	This will ensure that filetype variable is set correctly.  Some ATP
	tools behave in a different way in plaintex files.  For example
	TreeOfFiles function (it makes the variables |b:TreeOfFiles|,
	|b:ListOfFiles|, |b:TypeDict|, |b:LevelDict|).  It is recursive in
	LaTeX files but not in plain TeX files).  On this function is based
	the command |atp-:LocalCommands| which makes list of commands,
	environments and colours for Tab Completion and also |atp-:S| command.
	It is done so, because in plain tex there is no way to distinguish
	input files from input packages which we do not want to scan
	(especially recursively, which might be time consuming). 

PROJECT SCRIPT						*atp-ProjectScript*
    LOCAL PROJECT SCRIPT ~
<	The file: |b:atp_MainFile| . ".project.vim", called local project
	script, in the same directory as |b:atp_MainFile| stores values of
	variables saved before Vim left the  buffer (it is very similar to
	|View|).  It is a configuration script per project.  There is
	additional file which stores some global variables, see
	|atp-ProjectScript_Global|.
	
	Loading procedure searches for files which ends with '.project.vim'.
	There might be many such files in one directory.  The file is used
	which contains the current buffer in the list |b:ListOfFiles| or as
	a value of |b:atp_MainFile|.  If there wasn't any such the project
	scripts file then a new project script will be written for the current
	buffer.  Before writing the project script file if |b:ListOfFiles|
	doesn't exists it will be generated and written.

	The project script is stored locally so that it is possible to include
	it in a revision system (git, bzr, svn, etc.) and share it with
	collaborators.

	The variable |g:atp_ProjectLocalVariables| stores the names of
	variables written to the local project script, similarly the varaible
	|g:atp_ProjectGlobalVariables| is a list of variables stored in the
	global project file.

	The |atprc| file (and tex.vim file in after/ftplugin/ directory) is
	executed after the global project script and before the local one.
	(Precisely all the |:let| statements are executed before |atprc| file
	but all the |:set| and |:setl| statements are executed afterwards).
	The |:set| and |:setl| statements are executed only once (per project
	file).

	If you want to have two main files (for example a copy of a project
	in another directory below the project main directory), i.e.
	    main.tex
	    tmp/main.tex
	Then the easiest way is to open tmp/main.tex and adjust the variables:
	|b:atp_ProjectScriptFile| to point to tmp/main.tex.project.vim and
	|b:atp_MainFile| (this is necessary only if |g:atp_RelativePath|=0)
	and run |atp-:InputFiles|, then use |atp-:WriteProjectScript|.


							*b:atp_ProjectScript*
							*g:atp_ProjectScript*
	Setting one of the variables |b:atp_ProjectScript| or
	|g:atp_ProjectScript| to 0 the feature will be turned off.  Local
	variable, i.e. b: has precedence over the global one g:.  So you can
	turned off the feature for only specific files. The global variable
	will turn it off for all files.

							*g:atp_ProjectLocalVariables*
	Local and global variables can be stored in the local project script.
	The variables which are cached in local project script are listed in:
>
    let g:atp_ProjectLocalVariables = [
		\ "b:atp_MainFile", 	"g:atp_mapNn", 		"b:atp_autex", 
		\ "b:atp_TexCompiler", 	"b:atp_TexOptions", 	"b:atp_TexFlavor", 	
		\ "b:atp_auruns", 	"b:atp_ReloadOnErr",	"b:atp_OutDir",
		\ "b:atp_OpenViewer", 	"b:atp_XpdfServer",
		\ "b:atp_Viewer", 	"b:TreeOfFiles",	"b:ListOfFiles", 	
		\ "b:TypeDict", 	"b:LevelDict", 		"b:atp_BibCompiler", 
		\ "b:atp_StarEnvDefault", 	"b:atp_StarMathEnvDefault", 
		\ "b:atp_updatetime_insert", 	"b:atp_updatetime_normal"
		\ ] 
<
	If you want to alter value of this variable, it should be done in
	|atprc| or |vimrc| files.  When you remove a variable from this list it
	will not automattically be removed from the local project script.  You
	need to delete it your self (or delete the project script with
	|atp-:DeleteProjectScript|).

	If your vim doesn't have python support |+python| three more variables
	are stored: |b:atp_LocalEnvironments| |b:atp_LocalCommands|, and
	|b:atp_LocalColors|.  With |+python| this is not needed since
	|atp-:LocalCommands| is then very fast and is run on |BufEnter|.

							*b:atp_ProjectScriptFile*
>
    let b:atp_ProjectScriptFile = b:atp_MainFile.".project.vim"
<	This variables stores the name of the current local project script file.

							*atp-ProjectScript_Global*
    GLOBAL PROJECT SCRIPT ~
	There is also file for variables for all projects.  It stores values of
	global variables (by default it is "ftplugin/ATP_files/common_var.vim". 
	The global variables that are written in this file are given in Vim
	list: 
    							*g:atp_ProjectGlobalVariables*
>
		let g:atp_ProjectGlobalVariables = [ 
			\ 'g:atp_LatexPackages', 	
			\ 'g:atp_LatexClasses', 
			\ 'g:atp_Library' ]
<
	If you want to disable this feature for some reason you can set: >
		let g:atp_ProjectScript = 0
<	or >
		let b:atp_ProjectScript = 0
<	if you want to disable this feature only for a given buffer. 
	(The value of local variable overrides the value of global one!).
	Hint: (if you want to disable loading project script for one file): 
	    In your .vimrc file you can set the local variable via
	    autocommand group BufEnter or you can put an if statement in your
	    |atprc| file: >
		if expand("%:p") == <path_to_file>
		    let b:atp_ProjectScript = 0
		endif
<	    or you can add to the project scrpit: 
		 (1) write in its first line 'finish', or
		 (2) include in it 'let |b:atp_ProjectScript| = 0'.

	There are these commands: ~
:LoadProjectScript[!] [local/common]			*atp-:LoadProjectScript*
:WriteProjectScript[!] [local/common]			*atp-:WriteProjectScript*
:DeleteProjectScript[!] [local/common]			*atp-:DeleteProjectScript*
:ToggleProjectScript[!] [on/off]			*atp-:ToggleProjectScript*

	which do the obvious thing (if |g:atp_ProjectScript|=0 or |b:atp_ProjectScript|=0 they
	will not work).  The default value of the optional argument is "local".
	:DeleteProjectScript [local] command (with optional argument [local]) deletes
	the project script file for the current buffer (only the local one), with
	bang "!" it deletes also global project scrip.  The bang of
	:WriteProjectScript forces to write to project script even when
	project script is turned off (|b:atp_ProjectScript|==0 or
	!exists("|b:atp_ProjectScript|") && |g:atp_ProjectScript|==0).

	The command ':ToggleProjectScript [on/off]' turns on/off the feature
	for this buffer (it sets |b:atp_ProjectScript|).  When no argument is
	given it will toggle the value.  With bang it also sets the global
	variable |g:atp_ProjectScript|. |b:atp_ProjectScript| is by default in the >
	    g:atp_ProjectLocalVariables 
<	so it will be restored afterwards. |b:atp_ProjectScript| if defined
	overrides the value of global variable |g:atp_ProjectScript|.  So you can set
	in your atp file g:atp_ProjectScript = 0 and for some files using the
	if-construction: >
		let g:atp_ProjectScript = 0
		if expand("%:t") == "myfile.tex"
		    let b:atp_ProjectScript = 1
		endif
<	will turn on the feature only for myfile.tex.  Something more elaborate
	would be to set |b:atp_ProjectScript| only for files with modification time
	less than two days for example.

	Note: If you delete the project script for the current buffer it will be
	written after exiting Vim, unless you turn off the project feature.

	The project script is disabled for files which full path matches
	"texmf".  With the optional bang |atp-:LoadProjectScript| loads the
	common project script also for them. |atp-:WriteProjectScript| command
	will write the project script disregarding if the file is under texmf
	directory or not.

	Note: If you use this feature, you might need to use the commands:
	|atp-:LocalCommands| and |atp-:InputFiles| which will update
	b:atp_LocalCommands, b:atp_LocalColors, b:atp_LocalEnvironments and
	|b:TreeOfFiles|, |b:ListOfFiles|, |b:TypeDict| and |b:LevelDict|.  Use
	these commands with a bang "!".  The second set of variables is also
	updated by |atp-:S| (also with "!") and and |atp-:GotoFile| (with "!"
	as well).

	Note: Also when you add a package to tex you should remove the common
	project scrip, so that the new packages will be added to completion
	list. 

							*atp-:S*
:S[!] /{pattern}/ [flags]
	The pattern is a Vim pattern (with 'magic').  With bang "!" it
	regenerates the tree of input files.

	This is command does the same job as |/| but is recursive in the tree
	of files (so it is useful only in project files).  The syntax of this
	command is similar to |:vimgrep|.  It also sets the ` mark and thus it
	adds a position in the jump list (i.e. |atp-:S| as |/| belongs to the
	|jump-motions|)

	This works similarly to |:ijump|.  But also goes back to the root file
	(b:atp_MainFile).

	Note: this command is very fragil on the variable b:TreeOfFiles.  It
	should be uptodate if you use it (use the bang :S! or
	|atp-:InputFiles| command).

	It sets the alternate file to the buffer from which the search begun.
	Note that this means that if nothing was found the alternate file
	before search will be lost.

	Note: if 'shortmess' option contains 's' flag then 'Search hit BOTTOM
	...' and 'Search hit TOP ...' messages are not shown.

	The {pattern} is any Vim pattern as described in |pattern| (it was only
	tested with 'magic' set on).
			
	The supported [flags] are 'bcewWx'.  Their meaning is the same as flags
	for |search()| function, except the additional flag 'x'.  When used the
	|v:searchforward| value will not be changed.

	You can enclose the pattern with any non-ID character (see
	|'isident'|) instead of /, as far as it does not appear in the
	{pattern}.  Examples: >
			    :S pattern\_swith\_sspaces
<	will work but: >
			    :S pattern with spaces
<	will not.		

	Note that the function might be slow when the project files where not
	yet opened.

	There is a function to check where the input file is on the hard drive
	if the name in the input command doesn't include the full path.  It
	asks kpsewhich which directories to search, filters out 
	directories which are not under '/home' (I assume that there is your
	local texmf tree) and also directories which name contains one of the
	two keywords 'texlive' and 'kpsewhich'.  This makes the searching
	faster. 
							*atp-:S_input*
	Furthermore, the command is designed so that it can find all patterns
	'\\input' (and thus easily find next/previous input file).  You can
	use: >
		:S \\input
		:S \\input b 
<	and you can use |n| and |N| Vim normal commands. 
	Note that it if you go backward, then it means that it will find the
	most deep line, e.g.:
>
		file.tex
			----
			----
			\input{file.1} ---->  -------
					      -------
					      \input{file.1.1}
					      -------
	                ----X	 			      
<	':S /\\input/ b' in the X position fill find \input{file.1.1} assuming 
	file.1.1.tex does not include any other files. 

							*atp-:NInput* 	*atp->i*   *atp->gf*
							*atp-:PInput* 	*atp-<i*   *atp-<gf*
	Now it also doesn't search inside commented input files.  There two
	commands:
:[count]NInput, nmap [count]>gf, nmap [count]>i
:[count]PInput, nmap [count]<gf, nmap [count]<i
	which finds the [count]next/previous input line (also commented).  See
	|atp-:S_input| to find how it works.  They depend on |g:atp_mapNn|, if
	1 |atp-S:| is used if 0 Vim |search()| function.  To repeat search you
	can use |n| and |N| Vim normal commands.  These commands omit comment
	lines.

	If 'wrapscan' is on it will wrap around the file/project.

================================================================================
MAPS 		                     			*atp-mappings* 
							*atp-maps*

Lots of mappings which are given here uses #.  This is a convenient map on
British keyboards, but not in the US layout, you can change them for '`' or
some other key that it is not used in Vim (there are not many of them though).
The most commonly used latex-suite plugin uses similar set of mappings (but
there might be some differences).  The easy way to change imap leaders is by
using the variables:
							*g:atp_imap_leader_1*
>
	    g:atp_imap_leader_1 = "#"
<	    	for Greak letters and some math commands,
							*g:atp_imap_leader_2*
>
	    g:atp_imap_leader_2 = "##"
<	    	for font commands, (another good choice is "_") 
							*g:atp_imap_leader_3*
>
	    g:atp_imap_leader_3 = "]"
<	    	for environments, 
							*g:atp_imap_leader_4*
>
	    g:atp_imap_leader_4 = "["
<	    	for extra environments in the old layout (this will be removed).
							*g:atp_imap_over_leader*
>
	    g:atp_imap_over_leader = "`"
<		for imaps of all sort of accents.  See |atp-imaps-diacritics|,
		some maps in |atp-imaps-math-misc|, and also in vmaps:
		|atp-vmap-WrapSelection-accents|.
							|g:atp_map_forward_motion_leader|
>
	    g:atp_map_forward_motion_leader = ">"
<		for maps to |atp-:NInput|, |atp-:NSec|, .... , |atp-]e|.
							|g:atp_map_backward_motion_leader|
>
	    g:atp_map_backward_motion_leader = "<"
<		for maps to |atp-:PInput|, |atp-:PSec|, .... , |atp-<E|, |atp-<e|. 


Note: the best way to search for (insert) maps is to use the |atp-:Imap|
command.

If you want change the map the best way is to copy the rhs of map provided by
ATP, since before loading maps the script tests if map to such rhs already
exists.  To see it you can use on of '|:map| {lhs}<CR>' commands.

You can list imaps with |atp-:HelpMathIMaps| and |atp-:HelpEnvIMaps| but the
best way is to use |imap| directly.

All other mappings (|map|, |vmap|, |nmap|, ...) are using |<LocalLeader>| which can be
altered with the option |maplocalleader|.  A good alternate solution is to use "_"
instead of "##".

Maps are using the <buffer> option thus are local to the buffer.  To unmap you
also have to use this option, for example to unmap <LocalLeader>l issue the
command:
>
	:unmap <buffer> <LocalLeader>l
<
The maps are loaded unless you set one of variables: 'g:no_plugin_maps' or
'g:no_atp_maps' (disables maps defined in tex_atp.Vim), 'g:no_atp_toc_maps'
(disables maps defined in 'toc_atp.Vim'),  'g:atp_no_env_maps' (disables the
environment maps '[*', ']*') or |g:atp_tab_map| (disables the tab map
for completion, then completion is mapped to <C-X><C-O> and <C-X>o (for the non
expert mode) but there is no map for 'WrapSelection()', you have to provide 
one by your self).

Note: in all mappings '\' is set to your |<LocalLeader>| (and thus, in fact, the
maps listed below might differ).

Note: The list of commands might not be complete.

Note: There are many internal maps defined |<Plug>|, they are not documented,
but you can easily find them (you can start with
ftplugin/ATP_files/mappings.vim, where they are used in rhs of maps or you can
search for them inside the scripts). 

Note: you might like to use |'notimeout'| and |'nottimeout'| settings.
However, they require that there are no maps such that no lhs is a subset ot
the another, i.e. like "ab" and "abc".  With the default settings it is
shouldn't be a problem.

nmap ]], vmap ]]
	Goto next \begin{

nmap [[, vmap [[
	Goto previous \begin{

							*atp-][*
nmap ][, vmap ][
	Goto next \end{

							*atp-[]*
nmap [], vmap []
	Goto previous \end{

							|atp-gc|
nmap gcl, vmap gc 
	Goto end of comment group (current or next if not in comment).

							|atp-gC|
nmap gC, vmap gC
	Goto begin of comment group (current or previous if not in comment).
	    
							*atp-comment-lines*
							*atp-uncomment-lines*
							*g:atp_MapCommentLines*
nmap <LocalLeader>c, vmap <LocalLeader>c   -- comment
nmap <LocalLeader>u, vmap <LocalLeader>u   -- uncomment
	Comment/Uncomment lines (both in |Normal| and |Visual| modes). 

	Comment leader can be set with the variable g:atp_CommentLeader (by
	default it is '% ').  If you do not want this maps or you want to
	remap them to something else you can set |g:atp_MapCommentLines|=0 in
	your |vimrc| or |atprc| file and use <Plug>CommentLines,
	<Plug>UnCommentLines (these are normal maps), for example:
		nmap <LocalLeader>C 	<Plug>UnCommentLines
		vmap <LocalLeader>C 	<Plug>UnCommentLines
	A useful map for uncommenting |atp-_c| (i.e. |atp-select-comments|).

							*atp-<space>*
cmap <buffer> <C-Space> 	\_s\+
cmap <buffer> <C-_> 		\_s\+
    The <C-Space> map doesn't work in Vim, instead <C-@> is used which works
    as <C-Space>.  In Vim, and gVim as well.  See |atp-:ToggleSpace|.


IMAPS 							*atp-imaps*
All ATP imaps ae defined in several variables (vim lists): >
 g:atp_imap_greek_letters 
 g:atp_imap_math
 g:atp_imap_math_misc,
 g:atp_imap_diacritics
 g:atp_imap_environments
 g:atp_imap_fonts.
< Itmes of this vim lists are vim list of the following form:
[ <imap_command>, <imap_args>, <imap_leader>, <imap_lhs>, <imap_rhs>, <info> ]
The first four lists: g:atp_imap_greek_letters, g:atp_imap_math,
g:atp_imap_math_misc, are only defined when you enter LaTeX math mode.  For
example by typing '\(' or '\begin{align}', etc ... (this is recognized using
syntax: |synstack()|).  The imap defined in g:atp_imap_diacritics are only
defined in non math mode.  The advantage of this is that the imap o* which
produces \otimes doesn't affect typing o in LaTeX text mode.  In this way we
can provide many useful math imaps!

The function which makes the imaps is: atplib#MakeMaps(), the function which
toggles on/off math/text imaps is atplib#ToggleIMaps() (which now also set vim
options for math mode, see |g:atp_MathVimOptions|).

NOTE: If you are looking for some imap, using :imap you might not find it,
because some imaps are only defined when ATP is in insert mode.  Moreover, the
result depends if you are in a mathematical environment or not.  Here is
a trick how to find an imap which is only defined in insert mode.  First go to
insert mode, then press CTRL-O (see |i_CTRL-O|), and then type ':imap<CR>'.
If the cursor sands inside mathematical environment (for example inside \[:\])
the result will show mathematical imaps.  This is especially useful tip for
imaps which begins with ' - different imaps for accents in LaTeX text and math
modes.

							*atp-j_motion* *atp-k_motion*
imap CTRL-j, imap CTRL-k	- these are two motions (based on syntax)
which help to navigate thought brackets (but not only) in insert mode.
   
map CTRL-j, map CTRL-k	 	- as above but in normal mode.

	These motions emulate the behaviour of latex-suite place holder system <++>,
	without putting the placeholder into tex file.

FONT COMMANDS						*atp-imap-fonts*

Below are listed font imaps.  They work in text mode, or math mode, or if
there is only one given in both.  The map leader is defined by the variable
|g:atp_imap_leader_2|, which by default is set to '##' (another good
setting is '_')
	  	in text			in math ~
imap <LocalLeader>rm 	\textrm{}<Left>		\mathrm{}<Left>
imap <LocalLeader>te 	\textrm{}<Left>		\text{}<Left>
imap <LocalLeader>up	\textup{}<Left>
imap <LocalLeader>md	\textmd{}<Left>
imap <LocalLeader>sl	\textsl{}<Left>
imap <LocalLeader>sc	\textsc{}<Left>
imap <LocalLeader>em	\emph{}<Left>
imap <LocalLeader>it 	\textit{}<Left>		\mathit{}<Left>
imap <LocalLeader>sf 	\textsf{}<Left>		\mathsf{}<Left>
imap <LocalLeader>bf 	\textbf{}<Left>		\mathbf{}<Left>
imap <LocalLeader>bf 	\texttt{}<Left>		\mathtt{}<Left>
imap <LocalLeader>no	\textnormal{}<Left>	\mathnormal{}<Left>
imap <LocalLeader>bb	\(\mathbb{}<left>	\mathbb{}<Left>
imap <LocalLeader>cal	\(\mathcal{}<left>	\mathcal{}<Left>
imap <LocalLeader>cr	\(\mathscr{}<left>	\mathscr{}<Left>
imap <LocalLeader>fr	\(\mathfrak{}<left>	\mathfrak{}<Left>

							*atp-nmap-fonts*
These maps are also defined in normal mode.  They requre a motion afterwards,
i.e. <LocalLeader>rmw will wrap next word in \textrm{:} or \mathrm{:}.

							*atp-nmap-fonts-operator*
These maps are also available in as operators (|operator|, |g@|,
'operatorfunc').  That means you can type _bf{motion} to turn the text into
bold (\textbf or \mathbf depending if the motion starts in text or math).  The
map leader '_' is set by |g:atp_vmap_text_font_leader|.

							
GREEK LETTERS						*atp-imap-greek-letters*
Note: You can list this mappings using the command |atp-:HelpMathIMaps|.  You
might not see them using |:imap| unless the last cursor position in insert
mode was inside mathematics.
							*g:atp_imap_define_greek_letters*
Note: If you do not want imaps for greek letters you can set
      |g:atp_imap_define_greek_letters| = 0
Note: |g:atp_imap_leader_1| is used as a leader (with the default value '#').
Note: if the previous character is '\' the mapping will not work which allows
      writing '\#a', etc.  However, there is no check for '\\'.
imap #a 	\alpha
imap #b 	\beta
imap #c 	\chi
imap #d 	\delta
imap #e 	\epsilon
imap #ve	\varepsilon
imap #f 	\phi
imap #vf	\varphi
imap #y 	\psi
imap #h 	\eta
imap #k 	\kappa
imap #l 	\lambda
imap #i 	\iota
imap #m 	\mu
imap #n 	\nu
imap #p 	\pi
imap #o 	\theta
imap #vo 	\vartheta
imap #r 	\rho
imap #s 	\sigma
imap #vs 	\varsigma
imap #t 	\tau
imap #u 	\upsilon
imap #vp	\varpi
imap #w 	\omega
imap #x 	\xi
imap #z 	\zeta

Not all upper Greek letters are in LaTeX:
imap #D 	\Delta
imap #Y 	\Psi
imap #F 	\Phi
imap #G 	\Gamma
imap #L 	\Lambda
imap #M 	\Mu
imap #P 	\Pi
imap #O 	\Theta
imap #S 	\Sigma
imap #T 	\Tau
imap #U 	\Upsilon
imap #W 	\Omega

ENVIRONMENT IMAPS					*atp-imap-environments*
							*g:atp_imap_ShortEnvIMaps*
g:atp_imap_ShortEnvIMaps=1 
    By default the short environment imaps are defined, but if you set this
    variable to 0 you will get three letter abbreviations.  The only clashes
    is for proof (pro) and proposition (Pro) environments and itemize (ite)
    and \item (I).  You can also reconfigure them using the variables:
    g:atp_imap_{env_name} (for example g:atp_imap_theorem, if you don't want
    a map for particular environment set the corresponding variable to empty
    string ""), |g:atp_imap_leader_3| is used as a leader (the default is
    ]).  Map for letter environment is not defined when you use short imaps.

Note: you can list this mappings using the command |atp-:HelpEnvIMaps|.
Note: This can be effectively set only in |atprc| or |vimrc| files.

    These maps are fully customizable: both sides: the lhs and rhs side ! Here
    is how you can set the rhs:
							*g:atp_EnvNameCorollary*
							*g:atp_EnvNameDefinition*
							*g:atp_EnvNameExample*
							*g:atp_EnvNameLemma*
							*g:atp_EnvNameNote*
							*g:atp_EnvNameProposition*
							*g:atp_EnvNameRemark*
							*g:atp_EnvNameTheorem*
    This variables defines environment names put it the following environment imaps.

							*b:atp_StarEnvDefault*
    b:atp_StarEnvDefault variable with value "*" or "" (the default).  This
    star is added to theorem like environment imaps (|atp-imap-environments|).
    By default it will be restored by the project script.  See
    |g:atp_ProjectLocalVariables|.

    							*b:atp_StarMathEnvDefault*	
    b:atp_StarMathEnvDefault variable with values "*" or "" (the default).  It
    is added to align and equation imaps (|atp-imap-environments|).  By
    default it will be restored by the project script.  See
    |g:atp_ProjectLocalVariables|.

imap ]b   ]beg 		\begin{}<Left>
imap ]e   ]end		\end{}<Left>
imap ]C   ]cen 		\begin{center}<Cr>\end{center}<Esc>O

imap ]d   ]def 		\begin{definition}<Cr>\end{definition}<Esc>O
imap ]t   ]the 		\begin{theorem}<Cr>\end{theorem}<Esc>O
imap ]P   ]Pro		\begin{proposition}<Cr>\end{proposition}<Esc>O
imap ]l	  ]lem 		\begin{lemma}<Cr>\end{lemma}<Esc>O
imap ]r   ]rem 		\begin{remark}<Cr>\end{remark}<Esc>O
imap ]c   ]cor 		\begin{corollary}<Cr>\end{corollary}<Esc>O
imap ]p   ]pro		\begin{proof}<Cr>\end{proof}<Esc>O
imap ]x   ]exa 		\begin{example}<Cr>\end{example}<Esc>O
imap ]n   ]not 		\begin{note}<Cr>\end{note}<Esc>O

imap ]E   ]enu 		\begin{enumerate}<Cr>\end{enumerate}<Esc>O
imap ]I   ]ite 		\begin{itemize}<Cr>\end{itemize}<Esc>O

imap ]i   ]I		\item					*atp-item*
	This map has more features: if the preceding line is of the form:
		\item[(1)]
	then using this map in a next line will result with
		\item[(2)]
	This will work for other types of items, (1) -> (2), 1) -> 2),
	[1] -> [2], 1. -> 2. and also (a) -> (b), b) -> c), [c] -> [d],
	but also (1a) -> (1b). 
			

imap ]a   ]ali 		\begin{align}<Cr>\end{align}<Esc>O
imap ]q   ]equ 		\begin{equation}<Cr>\end{equation}<Esc>O

imap ]L   ]lef 		\begin{flushleft}<Cr>\end{flushleft}<Esc>O
imap ]R   ]rig 		\begin{flushright}<Cr>\end{flushright}<Esc>O

imap ]T   ]tik 		\begin{center}<CR>\begin{tikzpicture}<CR><CR>\end{tikzpicture}<CR>\end{center}<Up><Up>
imap ]f   ]fra 		\begin{frame}<Cr>\end{frame}<Esc>O

imap ]u	  ]tab		\begin{tabular}{}<CR>\end{tabular}

imap      ]let		\begin{letter}{<cursor>}
			    \opening{g:atp_letter_opening} 
			    \closing{g:atp_letter_closing}
			\end{letter}
							*g:atp_letter_opening*
							*g:atp_letter_closing*
    By default g:atp_letter_opening and g:atp_letter_closing are ''.


Next three sets of imaps: |atp-imap-math|, |atp-imap-math-misc| and
|atp-imap-diacritics| define imaps with overlapping keys (lhs), but note that
first two are defined only in math environment, while the last only in non
math environment.  In this way `' in math environment will produce \acute{}
while in non math \'{}. 

 							*atp-imaps-math-misc*
							*g:atp_imap_math_misc*
MATH IMAPS MISC						*g:atp_imap_define_math_misc*

    These imaps are defined in |g:atp_imap_math_misc| variable (except ]m and ]M
    imaps).  They might be turned off using |atp-:ToggleIMaps| commands or
    by setting |g:atp_imap_define_math_misc| variable to 0 (this should also
    work on the fly).

    These are very useful mappings for typing mathematics.  Some of the ideas
    were taken from TeX_9 by Elias Toivanen and also AuTeX by Carl Mueller.

    Note: you might not see them using |:imap| unless the last cursor position in
	  insert mode was inside mathematics.

AuTeX maps: ~
imap __ 	_{}<Left>
imap ^^		^{}<Left>
    You can set the leader for these two maps using g:atp_imap_subscript,
    g:atp_imap_supscript variables.  If you do not have any maps which begins
    with _ or ^ then you can set them to _ and ^, if this is the case the
    maps will not be fired if you type \_ or \^ (which means literal _ or ^ in
    LaTeX). 

imap ]m 	\(\)<Left><Left>
imap ]M 	\[\]<Left><Left>

imap #\		\setminus
imap #/		\frac{}{}
imap #&		\wedge
imap #N		\Nabla
imap #=		\equiv
imap `8		\infty		[the default '#' is not working, ` is used instead, 
				 but only if |g:atp_imap_leader_1|='#']
imap `6		\partial	[as above, you can also use \p<Tab>]
imap `D 	<Esc>vxi\frac{\partial}{\partial "}
				[ let me explain the above map: you type x`D
				and you get \frac{\partial}{\partial x} ]
imap #@		\circ
imap #*		\bigcap
imap #+		\bigcup
imap #\		\backslash
imap #.		\dot		[#.s will put \dots]

MATH ACCENTS AND DECORATIONS ~

These imaps are defined in g:atp_imap_math_misc variable.  They might be turned
off using |atp-:ToggleIMaps| commands or |g:atp_imap_define_math_misc| variable.

imap ``		\grave{}
imap `'		\acute{}
imap `>		\vec{}
imap `.		\dot{}
imap `v		\check{}
imap `_		\bar{}
imap `~		\tilde{}	[if g:atp_imap_wide is nonempty it is \widetilde{}]
imap `^		\hat{}		[as above]
imap `u		\underline{}
imap `o		\overline{}


 							*atp-imaps-math*
							*g:atp_imap_math*
MATH IMAPS						*g:atp_imap_define_math*

    These imaps are defined in |g:atp_imap_math| variable (except ]m and ]M
    imaps).  They might be turned off using |atp-:ToggleIMaps| commands or
    |g:atp_imap_define_math| variable (be setting it to 0, works on the fly).

    For convenience, there are:
imap ~~		\tilde{}	
imap ~^		\hat{}		[^^ is used for ^{}]		

    The last two maps and the following maps work around |'timeout'| vim
    setting (behave like |'notimeout'| was set):

imap ==		&=
imap =~		\cong
imap ~~		\approx

imap ++		\sum		/ but not if before stand ^ or _ - this allows to type X_++ X^++/
imap o+		\oplus
imap O+		\bigoplus
imap o-		\ominus
imap o.		\odot
imap O.		\bigodot
imap o*		\otimes
imap O*		\bigotimes
imap t*		\times
imap s+		\cup		[    set +]		/set = set theoretic/
imap s-		\setminus	[    set -]
imap S+		\bigcup		[big set +]
imap s*		\cap		[    set *]
imap S*		\bigcap		[big set *]
imap c*		\prod		[    cat *]		/cat = categorical/
imap c+		\coprod		[    cat +]
imap l*		\wedge		[    lat *, meet]	/lat = lattice theoretic/ 
imap L*		\bigwedge	[big lat *]
imap l+		\vee		[    lat +, join]
imap L+		\bigvee		[big lat +]
imap <=		\leq
imap >=		\geq
imap ->		\rightarrow	or \draw[->] [inside tikzpicture environment]
imap <-		\leftarrow	or \draw[<-] [inside tikzpicture environment]
imap #>		\rangle
imap #<		\langle
imap _>		\Rightarrow
imap <_		\Leftarrow
imap |-		\vdash
imap -|		\dashv
imap t<		\triangleleft
imap t>		\triangleright
imap s<		\subseteq	[    set <]
imap s>		\supseteq	[    set >]

    If you want to write 'o*' you can wait until |'timeoutlen'| passes or
    write 'o *' (TeX in math mode doesn't see spaces).

 							*atp-imaps-diacritics*
							*g:atp_imap_define_diacritics*
DIACRITICS						*g:atp_imap_diacritics*

These imaps are defined in g:atp_imap_math variable.  They might be turned off
using |atp-:ToggleIMaps| commands or |g:atp_imap_define_diacritics| variable
(be setting it to 0, works on the fly).

							*g:atp_diacritics*
if |g:atp_diacritics| is set to 2 (the default) to get \'{a} you have to type
a`', i.e. the map acts on the character just before the cursor.  See below
|g:atp_diacritics_letters|. Otherwise, if |g:atp_diacritics|=1 they act as
normal imaps, i.e. typing `' resolves to \'{} with cursor placed between the
brackets. If you set |g:atp_diacritics|=0 no diacritics imaps will be set.
Here is a list of all provided imaps to diacritics:

Note: if you are trying to set diavritics off for some specific files you can
do that in this way: >
    au BufEnter {path} let g:atp_diacritics = 0 | let g:atp_imap_diacritics = []
<
							*g:atp_diacritics_letters*
Inteligent diacritics works only after certain letters defined in the
dictionary |g:atp_diacritics_letters|, for example \'{} will work only after
one of the  letters in |g:atp_diacritics_letters|["'"]. The default value is:
>
    g:atp_diacritics_letters = {
	    \ "'"  : "aceginorsuyz",
	    \ "\"" : "aeiouy",
	    \ "`"  : "aeiouy",
	    \ "^"  : "aceghilosuwy",
	    \ "v"  : "acdehlnrstuz",
	    \ "b"  : "",
	    \ "d"  : "",
	    \ "H"  : "ou",
	    \ "~"  : "aeinouy",
	    \ "."  : "acegioz",
	    \ "c"  : "cegklnrst",
	    \ "t"  : "",
	    \ "2"  : "" }
<
Diacritics imaps: ~
>
    imap `'	\'{}
    imap `"	\"{}
    imap `^	\^{}
    imap `v	\v{}
    imap `b	\b{}
    imap `d	\d{}
    imap ``	\`{}
    imap `H	\H{}
    imap `~	\~{}
    imap `.	\.{}
    imap `c	\c{}
    imap `t	\t{}
<
You can also turn off diacritics imaps by setting |g:atp_imap_diacritics|=[] in
your |vimrc| or |atprc| file.

							*atp-:ToggleIMaps*
:ToggleIMaps
nmap, imap '<Tab> 
    This command toggles off/on impas defined in the vim lists
    g:atp_imap_math, g:atp_imap_math_misc and g:atp_imap_diacritics plus imaps
    to _{} and ^{}.

:ToggleSpace						*atp-:ToggleSpace*
	Turn on/off the cmap <Space> \_s\+.

LOG FILE MAPS						*atp-maps-log*
    This are available maps in the log file, when it was opened with
    |atp-:OpenLog| command >
	]e, [e 		- go to next/previous error message in log file 
	]w, [w		- go to next/previous warning message in log file 
	]c, [c		- go to next/previous citation warning message in log file 
	]r, [r		- go to next/previous reference warning message in log file 
	]i, [i		- go to next/previous info message in log file 
	]f, [f		- go to next/previous font info message in log file 
	]p, [p		- go to next/previous font package message in log file 
	]P, [P		- go to next/previous page in log file
	%		- searchpair for brackets: (:), [:], {:}, ... .
<	You can use |n| and |N| Vim normal commands to repeat previous search [count] times.

							*g:atp_vmap_text_font_leader*
							*atp-vmap-WrapSelection*
WRAP SELECTION VMAPS					*atp-vmap-InteligentWrapSelection*
	These are the provided maps in visual mode: >
	    vmap <buffer> _rm	:<C-U>IWrap ['\\textrm{'],	['\\mathrm{']<CR>
	    vmap <buffer> _em	:<C-U>IWrap ['\\emph{'],	['\\mathit{']<CR>
	    vmap <buffer> _it	:<C-U>IWrap ['\\textit{'],	['\\mathit{']<CR>
	    vmap <buffer> _sf	:<C-U>IWrap ['\\textsf{'],	['\\mathsf{']<CR>
	    vmap <buffer> _tt	:<C-U>IWrap ['\\texttt{'], 	['\\mathtt{']<CR>
	    vmap <buffer> _bf	:<C-U>IWrap ['\\textbf{'],	['\\mathbf{']<CR>
	    vmap <buffer> _bb	:<C-U>IWrap ['\\textbf{'],	['\\mathbb{']<CR>
	    vmap <buffer> _tx	:<C-U>IWrap ['\\textrm{'],	['\\text{']<CR>
	    vmap <buffer> _sl	:<C-U>IWrap \\textsl{<CR>
	    vmap <buffer> _sc	:<C-U>Wrap \\textsc{<CR>
	    vmap <buffer> _up	:<C-U>Wrap \\textup{<CR>
	    vmap <buffer> _md	:<C-U>Wrap \\textmd{<CR>
	    vmap <buffer> _fr	:<C-U>Wrap \\mathfrak{<CR>
	    vmap <buffer> _u	:<C-U>Wrap \\underline{<CR>
	    vmap <buffer> _o	:<C-U>Wrap \\overline{<CR>
	    vmap <buffer> _n	:<C-U>IWrap ['\\textnormal{'],['\\mathnormal{']<CR>
	    vmap <buffer> _cal	:<C-U>IWrap [''],['\\mathcal{']<CR>

	    vmap <LocalLeader>mb :Wrap \\mbox{ } begin<CR>
<   	Suggested maps: >
	    vmap <buffer> _tx	:<C-U>IWrap [''],['\\text{']<CR>
	    vmap <buffer> _in	:<C-U>IWrap [''],['\\intertext{']<CR>"
<	The leader '_' in above commands is configurable: the value of
	|g:atp_vmap_text_font_leader| is used (the default value is <LocalLeader>).

	Note: these maps are also available as operators, see |atp-nmap-fonts-operator|.

							*atp-nmap-WrapSelection*
							*atp-nmap-InteligentWrapSelection*
							*atp-omap-WrapSelection*
							*atp-omap-InteligentWrapSelection*
	The above maps are also valide in normal mode (operator mode). They require a motion
	afterwords, i.e. \rmw will wrap the following word inside \textrm{:}
	or \mathrm{:}.

	There is also: 
							*atp-vmap-\w*
	    						*atp-omap-\w*
>
	    omap <buffer> \w :set opfunc=ATP_LastWrap<CR>g@
	    vmap <buffer> \w :call atplib#various#RedoLastWrapSelection(["'<", "'>"])<CR>
< 	which repeats last wrappers used by |atp-:Wrap| or |atp-:IWrap|
	command or any other wrapping map.

	Another provided font wrapper: >
	    vmap <LocalLeader>fo	:exe ':Wrap {\usefont{'.g:atp_font_encoding.'}{}{}{}\selectfont\  }'.(len(g:atp_font_encoding)+11).'<CR>'
<	Where the variable: 				*g:atp_font_encoding*
>
	    g:atp_font_encoding
<	stores the default encoding which is 'OT1', unless you use fontenc
	package, then the default for fontenc is used (the last defined in
	\usepackage[...]{fontenc} see the 'Latex2e font selection'
	/font user guide/ available on CTAN).

							*atp-vmap-bracket-wrappers*
	Other wrappers: >
	    vmap m			:Wrap \( \)<CR>
	    vmap M			:Wrap \[ \]<CR>
	    vmap <LocalLeader>(		:Wrap ( ) begin<CR>
	    vmap <LocalLeader>[		:Wrap [ ] begin<CR>
	    vmap <LocalLeader>{		:Wrap { } begin<CR>
	    vmap <LocalLeader>)		:Wrap ( ) end<CR>
	    vmap <LocalLeader>]		:Wrap [ ] end<CR>
	    vmap <LocalLeader>}		:Wrap { } end<CR>
	    vmap <LocalLeader>b(	:Wrap \left( \right) begin<CR>
	    vmap <LocalLeader>b[	:Wrap \left[ \right] begin<CR>
	    vmap <LocalLeader>b(	:Wrap \left( \right) begin<CR>
	    vmap <LocalLeader>b[	:Wrap \left[ \right] end<CR>
	    vmap <LocalLeader>b{	:Wrap \left{ \right} end<CR>
	    vmap <LocalLeader>b{	:Wrap \left{ \right} end<CR>
<
							*atp-nmap-bracket-wrappers*
	The above maps work also in normal mode, but they require a motion
	command afterwards, e.g. <LocalLeader>{w will wrap the following word
	inside {:}. Only m and M differs, in normal mode they are
	<LocalLeader>m (wrap with \(:\))and <LocalLeader>M (wrap with \[:\]).

	The maps to put the selected text into an environment: >
	    vmap <LocalLeader>A	:Wrap \begin{align} \end{align} 0 1<CR>
	    vmap <LocalLeader>C	:Wrap \begin{center} \end{center} 0 1<CR>
	    vmap <LocalLeader>E	:Wrap \begin{equation} \end{equation} 0 1<CR>
	    vmap <LocalLeader>L	:Wrap \begin{flushleft} \end{flushleft} 0 1<CR>
	    vmap <LocalLeader>R	:Wrap \begin{flushright} \end{flushright} 0 1<CR>
<
							*atp-vmap-WrapSelection-accents*
							*atp-vmap-InteligentWrapSelection-accents*
	Accent wrappers: are using the value of |g:atp_imap_over_leader| as
	a map leader, by default it is '`':
>
	    vmap <silent><buffer> `'	:<C-U>IWrap ["\\'{"],["\\acute{"]<CR>
	    vmap <silent><buffer> `"	:<C-U>Wrap \"{ } end<CR>
	    vmap <silent><buffer> `^	:<C-U>Wrap \^{ } end<CR>
	    vmap <silent><buffer> `v	:<C-U>IWrap ["\\v{"],["\\check{"]<CR>
	    vmap <silent><buffer> ``	:<C-U>IWrap ["\\`{], ["\\grave{"]<CR>
	    vmap <silent><buffer> `b	:<C-U>Wrap \b{ } end<CR>
	    vmap <silent><buffer> `d	:<C-U>Wrap \d{ } end<CR>
	    vmap <silent><buffer> `H	:<C-U>Wrap \H{ } end<CR>
	    vmap <silent><buffer> `~	:<C-U>Wrap \~{ } end<CR>
	    vmap <silent><buffer> `.	:<C-U>IWrap ["\\.{], ["\\dot{"]<CR>
	    vmap <silent><buffer> `c	:<C-U>Wrap \c{ } end<CR>
	    vmap <silent><buffer> `t	:<C-U>Wrap \t{ } end<CR>
<	The leader <LocalLeader> can be changes using the variable *g:atp_vmap_environment_leader* 
	(its default value is <LocalLeader>).
	Note: that the arguments for this command must be put in ':' or ":".
   	the highlighted text will put inside \textbf{ }. 
================================================================================
ABBREVIATIONS						*atp-abbreviations*

    The following abbreviations are defined:
	+- for \pm
	+| for \dagger
	++ for \ddager
	=<env_name>= for environments. 

    You can use |atp-completion| (<Tab>) for abbreviation names, see
    |atp-completion-abbreviations|.

    Locally defined environments are also supported (the one defined in
    |b:atp_LocalEnvironments|). They are made by the command
    |atp-:LocalCommands|, e.g if g:atp_local_completion == 2 then they are
    made on startup.

    If you need something different than abbreviation for
	\begin{theorem}
	     <Cursor placed here>
	\end{theorem}
    for example:
	\begin{corollary}<Cursor placed here>
	\end{corollary}
    You can set the variable g:atp_abbreviation_{environment_name}. It is list
    with two elements. First element is used after \begin{...} and the second
    after \end{...}. For the above examples:
	let g:atp_abbreviation_theorem		= [ '<CR>', '<ESC>O' ]
	let g:atp_abbreviation_corollary	= [ '<CR>', '<ESC><UP>A' ]
    The first one is the default so you do not need to set it. In the second
    example the abbreviation command will look like: >
	abbreviate =corollary= \begin{corollary}<CR>\end{corollary}<ESC><UP>A
<   This will only work for b:atp_LocalEnvironments; LaTeX and AMS
    environments are set accordingly.
    Environment name abbreviations are defined only if there were not defined.
    So you can override the settings using |atprc| file (or |vimrc| file).

    Furthermore, you can change the "=":
    							*g:atp_iabbrev_leader*
    let g:atp_iabbrev_leader = "="
	It is used  in insert mode abbreviations like: =theorem=. 

    							*g:atp_no_local_abbreviations*
    Use |g:atp_no_local_abbreviations| if you don't want to have abbreviations
    to locally defined environments (this takes time if your vim was compiled
    without |+python| feature, as it runs |atp-:LocalCommands| command - which
    is slow in this case).

================================================================================
DEBUGGING						*atp-errors*
    This section describes some limitation of ATP (as you see, this section is
    not written, but the aim is to make it disappear anyway ;).

    There are many debug variables with names g:atp_debug{fname} where {fname} is
    a shortname of the function for which it will turn on the debug info. These
    variables are documented in ftplugin/ATP_files/options.vim file.

							*atp-errors-bibsearch*
    A possible error which may occur using the :BibSearch commands has a simple
    cause: we count number of brackets '()', '{}' and '"' (but nor '\"') to see
    where the bib entry ends and where to join lines. The message error is echoed
    when more than 30 lines where processed and the matching bracket was not found
    (or the number of '"' is odd). Look at your bib file at the specified
    position.  Syntax highlighting for bib files can help you finding where such
    an error is located. (After reading the bib file comment lines and lines which
    begin with @string are removed, so that the brackets in comment lines do not
    count.)

================================================================================
EDITING TOOLS							*atp-editing*

							*atp-visual*
	visual mode: i), i(, a), a(, i], i[, a], a[, i}, i{, a}, a{,
	ie, iE, ae, im, am, ip, ap, iS, aS, <LocalLeader>sc normal
	and mode: <LocalLeader>sc. 

	They select the current environment in two ways: >
	    i 		- inner
	    a 		- outer
	    e 		- environment 
	    p		- paragraph	  
	    m		- math zones: \(:\), $:$, \[:\], $$:$$, 
			  or math environment \begin:\end.ard
			  search is set by ATP
	    (,),{,},[,]	- brackets
	    s	- syntax
<							*atp-vi)* *atp-vi(*
							*atp-vi]* *atp-vi[*
vmap [count]i), [count]i]
vmap [count]i(, [count]i[
	i), i(, i], i[ -- select between (:) and [:] without the bracket
	sizes, i.e. '\left(XXX\right)' i( and i) will select 'XXX'. These maps
	will also select between \(:\), and \[:\].

	The [count] has the same meaning as in |i(|.

	Note: the bracket size is included, i.e. 'vi(' on '\left' in
	'\left(...\right)' will match the inside of the following bracket
	pair. If you want to match as vim's 'vi(' would do, add a count at
	this position: 'v2i('.
							*atp-vi}* *atp-vi{*
vmap [counti]i}
vmap [counti]i{   
	 i}, i{ -- select between {:} and \{:\} (omitting sizes as above)

	 Note: the bracket size is included (see |atp-vi)|).
 							*atp-va)* *atp-va(*
							*atp-va]* *atp-va[*
vmap [count]a), [count]a]
vmap [count]a(, [count]a[
	a), a(, a], a[ -- select between (:) and [:] together with the
	brackets and the bracket sizes, i.e. a) and a( over '\left(XXX\right)'
	will select whole sequence. These map will not select \(:\) and \[:\]
	(use |atp-am| instead)

	Note: the bracket size is included (see |atp-vi)|).
							*atp-va}* *atp-va{*
vmap [counti]a}
vmap [counti]a{   
	a}, a{ -- select between {:}, \{:\} together with the sizes.

	Note: the bracket size is included (see |atp-vi)|).

							*atp-omap-i)* *atp-omap-i(*
							*atp-omap-i]* *atp-omap-i[*
							*atp-omap-i}* *atp-omap-i{*
 							*atp-omap-a)* *atp-omap-a(*
							*atp-omap-a]* *atp-omap-a[*
							*atp-omap-a}* *atp-omap-a{*

	The corresponding operator maps are defined. For example you can use
	"ci(" to change the inner part of '\left(...\right)' (it will also
	work when the cursor is somewhere over '\left'), or "c2a{" ...

							*atp-vie* *atp-viE* *atp-vae*
	ie, iE, ae select environment: from the nearest \begin (top) to the nearest \end (bottom).	

		'viE' selects a bit more than 'vie' but less than 'vae', it
		selects a bracket pair before the beginning of the inner part
		of an environment, so it can be environment name or an option
		just after. 	

        Note: maing the omap ie and ae act linear is not easy ('omap ie Vie')
        did not work for me, also the |o_V| wasn't.  Probably the best advice
        is to go through visual mode with: 'Vae'.

							*atp-im* *atp-am*
	im, am	selects mathematics operators: you can use "vim" to select
	inlnie math, "xim" to remove it "cim", ...
							*g:atp_SelectInlineMath_withSpace*
>
  let g:atp_SelectInlineMath_withSpace = 0
<       By default |atp-im| will not select spaces just after, before
	\(:\) (and other math environments), i.e. in \(  xxx  \) only xxx will
	be selected. If you set this variable to 1 always whole inner part of
	math will be selected.

							*atp-ip* *atp-ap*
	ip, ap  selects paragraph. 
		In inner mode (ip): from the nearest >
			\begin, \end, \par, \newline, ^\s*% (comment) or empty line (top) 
<		to the nearest >
			\begin, \end, \par, \newline,  ^\s*% (comment)or empty line (bottom).
<		in outer mode (ap): from the nearest >
			\par or empty line (top) 
<		to the nearest >
			\par or empty line (bottom).
<						
	ip over a commented line will match all the comment like =c

	The correspondin operator maps are defined. For example you can use
	xim to delete the inner part of math mode \(:\), etc.

							*atp-viS* *atp-vaS*
	iS, aS	selects using syntax stack (see |synstack()|), inner is the
		top element in the syntax stack (the highlighted area will be
		small) and outer uses the most bottom element in the syntax
		stack (the resulting are will be wide). Some syntax groups are
		filtered out (like 'texDocZone') which not always are
		synchronised.
							*atp-select-comments*
							*g:atp_MapSelectComment*
							*atp-=c*
	=c	
		select comment lines which begin with '^\s*%'. If not in
		comment line, end visual mode. You can change this map with
		variables g:atp_MapSelectComment (this can be only changed in
		atprc or vimrc file, you need restart Vim, or use
		|atp-:ReloadATP|) .
							*atp-omap-=c*
		The corresponding operator map is defined, e.g. you can use
		d=c to delete the comment.


							*atp-gW*	
nmap gW
	Quite useful normal map to: >
	    m`vipgq``
<	It is mapped to gW (in normal mode). It is slightly better than the
	above. If you use autselect in 'clipboard' vim option, it will not
	ovwerwrite what is in the "* register (what would happen due to
	useage of the visual mode).

							*atp-g<*
							*atp-g>*	
nmaps: g>, g<				{not defined by default}
	A normal maps to >
	    m`vipg>``
	    m`vip2g>``
<	You can put this into your |atprc| file:  >
	    nnoremap <buffer> g>	:<c-u>call feedkeys("m`vip".(v:count1 <= 1 ? "" : v:count1).">``", 't')<cr>
	    nnoremap <buffer> g<	:<c-u>call feedkeys("m`vip".(v:count1 <= 1 ? "" : v:count1)."<``", 't')<cr>
<

							*atp-r*
nmap r{char}
	Over any charackter which is not a bracket: (:), [:], {:} it acts as
	|r| command. Over a bracket which has a closing bracket and if {char}
	is another bracket it replaces both opening and closing bracket. When
	replacing brackets it will not remember the changing bracket for the
	|.| command, so you cannot use |.| to change more brackets, but if
	|atp-r| was used for changing text (non-brackets, or not-closed/opened
	brackets) then the action can be repeated with |.|.


================================================================================
REQUIREMENTS						*atp-requirements*

This plugin requires Vim version 7.3.  Several tools uses syntax, so even if
you do not like colours on the screen you should set "syntax on". For example,
the recognition of math mode used by |atp-completion|, and |atp-:TexAlign|
command (but also some other things, and some maps!).

							*atp-requirements-python*
ATP uses python 2.7 (also works with python 3). You need psutil library which
you can get from here:
    http://code.google.com/p/psutil/
Other libraries are standard ones so they should be available. If you have
a problem you can try to set g:atp_debugPythonCompiler=1 and then look at the
file PythonCompiler.log under |g:atp_TempDir| it will contain python errors.

It is nice to have 'texdoc' program. This plugin maps <F1> to a function which
calls it. This allows to speed up searches for documentation. Also the option
'keywordprg' has the value "texdoc -m", thus pressing 'K' (see |K|) over a tex
package should open you the package documentation. The same applies to this
help file.

Another good programs are: texloganalyzer (which is now not used by ATP) and pdffonts
There is a map to use pdffonts, see: |pdffonts|.

The command |atp-:WordCount| is using detex program. It is included in TexLive
tex distribution.

================================================================================
NOTES ON VIEWERS                          		*atp-Viewers*

See the section |atp-Viewers_Options| how to set options for viewer programs.

 							*atp-Viewers-Xpdf*
Xpdf ~
	It is supported. It is configured in the way that when your tex file
	have errors, Xpdf viewer will not reload your file, which I found
	useful. Xpdf supports forward searching (vim->Xpdf) with command:
	|atp-:SyncTex| >
		:SyncTex
		map <LocalLeader>f
		map <S-LeftMouse>
<	Read also |atp-:SyncTex_Xpdf-hack| and see |atp-:SetXpdf| command
	description.  You can set your own options of Xpdf using
	|b:atp_xpdfOptions| (or g:atp_xpdfOptions), for example:
>
	    let b:atp_xpdfOptions=['-bg', 'NavajoWhite4', '-fg', 'black', '-mattecolor', 'burylwood']
<
	will make Xpdf view different. This is helpful when you edit to
	files, and do not want to mix them. Another nice example:
>
	    let b:atp_xpdfOptions="-bg Grey30 -mattecolor SlateBlue2 -papercolor White"
<

	You can set forward searching for Xpdf (from version 3.03, already
	available here: http://foolabs.com/xpdf/download.html):

Xpdf: inverse search ~
							(see also |atp_inverse_search|)
	Add this line to your $HOME/.xpdfrc file: >
	    bind shift-mousePress1 any 'run(python $HOME/.vim/ftplugin/ATP_files/reverse_search.py --synctex  "%f" %i %j %k)'
<	Note: %i, %j, %k should not be quoted.
	Pressing <Shift>+<Left_Mouse> will do forward search, i.e. it will set
	vim according to mouse cursor position over Xpdf. See man page of xpdf
	how to bind other keys.

	Note: to use this xpdf have to be opened giving full path to the file.
	This is important when you open a file from a terminal. Otherwise
	reverse_search.py as invoked above by the run() command will look for
	the tex file in the directory: '$HOME/.vim/ftplugin/ATP_files'.
	Furthermore, it will make new file there which ATP will try to process.
	A workaround this should be to place reverse_search somewhere in your
	path and make in executable and change the run() command to
	'run(reverse_search.py --synctex %f %i %j %k)'. This is not tested solution.

	You can debug Xpdf if something doesn't work: open the file from terminal
	with 'xpdf -cmd' see the man page of Xpdf.

Evince ~
	Works fine.
							*atp-Viewers-Okular*
Okular ~
	Works fine. It supports both forward (Vim->Okular) and inverse
	(Okular->Vim) searches. Okular supports forward searching (vim->Okular)
	with command: |atp-:SyncTex| >
		:SyncTex
		map <LocalLeader>f
		map <S-LeftMouse>
<
Okular: inverse search ~
	Here is how to configure inverse searching (Okular->Vim) with
	|reverse_search.py| python script shifted with ATP: 

	open Okular and go to >
		settings>Configure Okular>Editor
<	and set >
		Editor		Custom Text Editor
		Command		python $HOME/.vim/ftplugin/ATP_files/reverse_search.py '%f' '%l'
<	NOTE: You must substitute $HOME directory to its value!!! It will not
	work other way. You can also copy the script somewhere inside your
	$PATH but then when this script will change you have to keep in mind
	to copy it again. 

	If it is not working for you, please report it, you can also
	use: >
	    gvim --remote-wait +%l "+normal %c|" %f
<
							*atp-:SyncTex_with_Okular*
	NOTE: :SyncTex command uses "--unique" switch for okular. However,
	when you do not set |b:atp_okularOptions| to ["--unique"] as well, then
	using :SyncTex will open new instance of Okular regardless if it was
	opened or not. You can use "--unique" as an Okular option (in
	g:atp_okularOptins or b:atp_okularOptions), but the if you open many
	files tex, all will use only one instance of Okular. This is
	a limitation of using Okular. Xpdf has a server option which allows
	for vim->Xpdf communication to the right Xpdf instance.  

	Then you can use <Shift>+<Left_Mouse> in Okular to synchronize the Vim
	(gVim) with pdf. 

							*atp-Viewers-Skim*
							*atp-Viewers-Open*
Skim ~
Open ~
	Forward searching (vim -> open): ~
        To enable forward searching you need to:
							*g:atp_DisplaylinePath*
	ATP is using the following path to displayline:
            /Applications/Skim.app/Contents/SharedSupport/displayline
	it is defined in the variable |g:atp_DisplaylinePath|.

	To set reverse searching for Skim (Skim -> Vim):
	   Enable Preferences > Sync > Check for file changes
	   Preset   = Custom
	   Command  = /usr/local/bin/mvim
	   Argument = --remote-silent +":%line" "%file"
	    	    

Kpdf ~
	Works fine (moves page a little bit when updates a file).

EpdfView ~
	This viewer does not support automatic reloads when the file changes
	(but it seems that the work is in progress). You have to issue CTRL-R
	yourself when the file is changed.

AcroRead ~
	As with epdfview (with the difference that it supports automatic
	updates, but it do not works somehow). There is a way to configure
	forward searching (Vim->AcroRead)! but it is not supported yet, if you
	really want it, write to me.
							*atp-Viewers-Xdvi*
Xdvi ~
	Works fine. The file will be updated after a click (or use the xdvi
	options '-watchfile 1' see man xdvi for explanations). You can set
	forward/reverse searching by the command |SetXdvi| then use
	|atp-:SyncTex| for forward searching (Vim->Xdvi). To get reverse
	searching Xdvi must be opened by ATP (:View, or any other
	command)

	If you want to use Vim you have to run it with the command: >
 		vim --servername xdvi <file>
<	You can pick any server name.
	
	ATP supports forward (Vim->Xdvi) and inverse (Xdvi->Vim) searching for
	Xdvi. The forward search is set by ATP (see |atp:SyncTex|), the
	inverse search is set by: >
	    let b:atp_TexCompiler	= "latex"
	    let b:atp_TexOptions	= ["-src-specials"]
	    let b:atp_Viewer		= "xdvi" 
	    let b:atp_xdviOptions	= ["-editor", "'gvim --remote-wait +%l %f'", "-watchfile", "1"]
<	They are not set by default, however there is simple command to set
	them at once |atp-:SetXdvi|.	
	This are excellent sources of information on this:
	    http://xdvi.sourceforge.net/inverse-search.html
	    http://Vim.wikia.com/wiki/Vim_can_interact_with_xdvi
	Note the watchfile switch for xdvi: with it xdvi will reload the file,
	if needed, every second.

							*atp-Viewers-Zathura*
Zathura	~
	Use the '-s' switch to enable syntex support for zathura. To enable
	backwards synchronisation you need to set the editor command with the
	'-x' flag:
	    zathura -s -x "gvim --servername synctex --remote +%{line} %{input}"

Mupdf ~
	It is the fastest pdf viewer program ever made, why? because it
	renders only one page :). But it can be nicely set with ATP: via
	autocommands and |atp-:SyncTex| you can load a page where the cursor is
	located (for example with autocommand event |CursorHold|). This might be
	nice on a big enough monitor on which you can see both vim and mupdf
	on one screen.

================================================================================
INVERSE SEARCHING					*atp_inverse_search*

							*reverse_search.py*
	ATP comes with a python script which can do inverse searching. It is
	based on synctex and a vim function |atplib#FindAndOpen()|. The last
	function searches which running vim/gvim instance holds the {file},
	and updates the cursor location. The syntax is as follows:

	    reverse_search.py [--vim] {file} {line} [column]
	    reverse_search.py [--vim] --synctex {file} {page} {x-coord} {y-coord}

	First syntax will work for viewers which calls synctex themselves
	(like Okular) and has escapes for {line} (and [column]).  The second
	syntax is for viewers which have only escapes characters for {page}
	number and the coordinates {x-coord} and {y-coord} (for example Xpdf).

	Note: {x-coord} and {y-coord} counts from top left corner in big
	points (72dpi), for example Xpdf (ver. 3.03) gives escapes for x,
	y coordinates counting from bottom left corner)

	Preferably you should call this command with >
	    python PATH/reverse_search.py  {args}
<	Then when you update ATP you will not miss updates of |reverse_search.py|. 
	Another good solution is to link |reverse_search.py| somewhere in the
	$PATH and make it executable. If you just copy it you might miss when
	it will be updated. If you set the command as above (with python
	before the path to reverse_search.py) you do not need to make
	reverse_search.py executable.  Note, that otherwise whenever you update
	ATP you will have to make the script executable!

	By default, the script is using gvim. If you prefer to use vim add
	[--vim] switch: >
	    python PATH/reverse_search --gvim --synctex {file} {page} {x-coord} {y-coord}
<
	Note: |reverse_search.py| doesn't like when you suspend an instance of
	vim (any).

	|reverse_search.py| write to a debug file /tmp/atp_RevSearch.py.

	Note: if inverse searching stopped working for you, try to recompile
	the document.

	Finally, |reverse_search.py| will forward error messages (or error code
	if error message was not found) back to vim. This is only possible if
	|reverse_search.py| found the correct vim server.

							*atplib#FindAndOpen()*	
	The function atplib#FindAndOpen() asks each running gvim server if is
	is "hosting" source of the file %f. Then it uses this server to set
	the line (but it doesn't check if the cursor is in the right window!).

	Note: if you like command line Vim (which has its own beauty
	- actually I'm just typing in it :) you need to set up Vim server
	  option on startup: >
 		vim --servername VIM <file>

<	|atplib#FindAndOpen()| will find a correct tabpage and window if
	necessary and focus vim in the right one.
	Limitations: ~
	The project files which are split into many input files are not yet
	supported.
	

================================================================================
TIPS                               			*atp-tips*

If you have any nice tip on editing (La)TeX with Vim or ATP :) you can share it
here (my email you'll find on top of the help file), or put them on the script
web page. 


nmap gS :%s/<c-r>=expand("<cword>")<cr>/
				Pull word under the cursor to substitute
				command. 

:g/^[^%]*\\usepackge/#		List loaded packages with line numbers
				If you want to keepjumps and do not move the
				cursor you can use this:
:g/^[^%]*\\usepackage/keepjumps #|normal ''

y/\\begin{document}/		When standing on 1st line - copy the preamble
				(possibly to a register)
:g/^\s*%/d			Delete comment lines 				

:g/\(^\s*\n\)\{2,}/d		Compress empty lines 
					/ when there are more than two empty
					lines it leaves just one /  
				or even better:
:g/^\s*$/,/\S/-j
				or even better:
:v/./,/./-j
				but this will compress only empty lines,
				see http://vim.wikia.com/wiki/Power_of_g for
				explanation.

:g/\\begin{table}/+;/\\end{table}/-s/\(\\\\\s*\)\@<!\n/
				Joint lines inside table environment which
				doesn't end with \\, i.e. from >
				    \begin{table}
					    a&b
					    c&d\\
					    A&B&C
					    &D\\
				    \end{table}
<				it will make >
				    \begin{table}
					    a&b&c&d\\
					    A&B&C&D\\
				    \end{table}
<				(modulo white spaces which might appear)

vipgq				Format inner paragraph. Or even better:
m`vipgq``			This is so nice that I added a map: >
				    nmap gq	m`vipgq``		
<
m`vip>``			
m`vip<``			Indent inner paragraph, they are mapped to: >
				    nmap g>	m`vip>``
				    nmap g<	m`vip<``
<				There are also defined maps: 2g>, 3g> , 4g>
				up to 6g>.

:Texdoc amsCTRL-d		Show tex documentation which matches ams (the
				completion for Texdoc command finds matches in
				alias files of texdoc :!texdoc -f).

\ref{thm:<Tab>			It will list all cross references to theorems
\ref{^thm:<S-Tab>		(if you use the prefix thm: for theorems).
				
				If you want to change the name of a command,
				you can try:
augroup DelCommands
    au VimEnter *tex delcommand SetXdvi
    au VimEnter *tex delcommand SetXpdf
augroup END
command! -buffer	Xdvi	:call SetXdvi()
command! -buffer	Xpdf	:call SetXpdf()

				However, not all functions are defined without
				<SID> (you can always try to reach me).

:'<,'>WrapSelection @q		Wrap a visual area with wrapper from the
				register q and with the default '}' end
				wrapper.
:'<,'>WrapSelection @q,@w	As above but with the end wrapper from
				register w. 

:map ]=		]sz=		Goto the first spelling error and list 
:map [=		[sz=		suggestions. Another version is to use
				]S and [S instead of ]s and [s.
				
imap <C-B>	<C-o>b<C-o>de	Delete word before the cursor
		<C-o>vbx	(this an alternative using visual mode).

The vim motions w and b in TeX/LaTeX might behave a bitt better if they treat
\ as a place where word starts/ends. If you add \ to 'iskeyword' option, then
this will not work. As a workaround you can use the following functions:

fun! Wmotion(count, mode)
    let i=1
    let beg_pos = getpos(".")
    while i <= a:count
	if getline(line("."))[col(".")-1:col(".")] =~? '^\\\w'
	    normal! w
	endif
	normal! w
	if getline(line("."))[col(".")-2] == "\\"
	    normal! h
	endif
	let i+=1
    endwhile
    if a:mode ==? 'v'
	if a:mode ==# 'v'
	    normal! v
	else
	    normal! V
	endif
	call cursor(beg_pos[1:2])
	normal! o
    endif
endfun
nmap <buffer> <silent> w :<C-U>call Wmotion(v:count1, 'n')<CR>
vmap <buffer> <silent> w :<C-U>call Wmotion(v:count1, 'v')<CR>
omap <buffer> <silent> w :<C-U>call Wmotion(v:count1, 'o')<CR>

fun! Bmotion(count, mode)
    let i=1
    let beg_pos = getpos(".")
    while i <= a:count
	normal! b
	if getline(line("."))[col(".")-2] == "\\"
	    normal! h
	endif
	let i+=1
    endwhile
    if a:mode ==? 'v'
	if a:mode ==# 'v'
	    normal! v
	else
	    normal! V
	endif
	call cursor(beg_pos[1:2])
	normal! o
    endif
endfun
map <buffer> <silent> b :<C-U>call Bmotion(v:count1, 'n')<CR>
vmap <buffer> <silent> b :<C-U>call Bmotion(v:count1, 'v')<CR>
omap <buffer> <silent> b :<C-U>call Bmotion(v:count1, 'o')<CR>

fun! Emotion(count, mode)
    let i=1
    let beg_pos = getpos(".")
    while i <= a:count
	normal! e
	if getline(line("."))[col(".")-1] =~ "\\"
	    normal! e
	endif
	let i+=1
    endwhile
    if a:mode ==# 'o'
	normal! l
    elseif a:mode ==? 'v'
	if a:mode ==# 'v'
	    normal! v
	else
	    normal! V
	endif
	call cursor(beg_pos[1:2])
	normal! o
    endif
endfun
map <buffer> <silent> e :<C-U>call Emotion(v:count1, 'n')<CR>
vmap <buffer> <silent> e :<C-U>call Emotion(v:count1, 'v')<CR>
omap <buffer> <silent> e :<C-U>call Emotion(v:count1, 'o')<CR>

fun! OuterWord()
    call search('\<\|\\', 'cb')
    if getline(line("."))[col(".")-2] == "\\"
	normal! h
    endif
    normal ve
endfun
vmap <buffer> <silent> aw <Esc>:call OuterWord()<CR>

================================================================================
COLOUR HIGHLIGHTING AND SYNTAX GROUPS			*atp-highlight*

When the cursor is positioned on \begin{envname} or \end{envname} both
corresponding \begin:\end get highlighted with syntax group MatchParen. 
							*g:atp_HighlightMatchingPair*
>
 g:atp_HighlightMatchingPair = 1
<
If you set this variable to 0 highlighting will be turned off.

There is a colour scheme included: coots-beauty-256. You need 256 colours to
use it (in the terminal). 

These are the highlights groups defined for various files and the default
links:

1) ToC file >
	highlight atp_FileName		Title
	highlight atp_LineNr		LineNr
	highlight atp_Number		Number
	highlight atp_Chapter		Label
	highlight atp_Section		Label
	highlight atp_SubSection	Label
	highlight atp_Abstract		Label
<		*this group highlights abstract and all the unnumbered chapters
		 and the bibliography.

    The chapter group highlights or chapters, or sections, or parts, depending
    what is your top level section in your latex document. This applies,
    accordingly, to other groups.

2) Labels file >
	highlight atp_label_FileName	Title
	highlight atp_label_LineNr	LineNr
	highlight atp_label_Name 	Label
	highlight atp_label_Counter 	Keyword
<
3) BibSearch file
    this is very much the same as the standard syntax for bib files. Groups
    are named bibsearch<NAME> instead of bib<NAME>. There is one more group
    added:
>
	highlight bibsearchInfo
<
    which highlights the line number of the bib entry in the bib file.  All
    bibsearch groups are by default linked to the bib groups.

    Yet, there is no default highlighting, try coots-beauty-256 colour scheme.
    If you like it, I'm glad, if you have a nice (non standard) colour scheme,
    I'm happy to get it, if you like to share it.

4) Status line:
    The notification message that your compiler is running can be highlighted.
    For this set the variables: >
    	g:atp_notification_{g:colors_name}_gui
    	g:atp_notification_{g:colors_name}_guifg
    	g:atp_notification_{g:colors_name}_guibg
<   Their values will be passed to gui guifg and guibg values of the highlight
    command. The g:colors_name variable is set by colour scheme. Usually it is
    just the colour scheme name but there might be a difference, for example:
    the provided colour scheme file name is 'coots-beauty-256' but the variable
    is set to 'coots_beauty_256'. Example: >
    	let g:atp_notification_coots_beauty_256_gui="DeepPink4"
<   will set the foreground colour of 'pdfLaTeX' message to DeepPink4.

							*atp-highlight-notification*
    The status message 'LaTeX' ( if you use latex or 'pdfLaTeX' when you use
    pdflatex, and so on) can be highlighted. There are several variables to
    set this: >
		g:atp_notification_{g:colors_name}_gui
		g:atp_notification_{g:colors_name}_guifg
		g:atp_notification_{g:colors_name}_guibg

		g:atp_notification_{g:colors_name}_cterm
		g:atp_notification_{g:colors_name}_ctermfg
		g:atp_notification_{g:colors_name}_ctermbg
<   where g:colors_name is the name of the colour scheme, for example the
    supplied colour scheme with atp 'runtimepath/colors/coots-beauty-256' has
    name 'coots_beauty_256' so the first variable should be >
		g:atp_highlight_coots_beauty_256_gui
<   value of these variables are used to set highlight for the group UserN
    where N is the value of g:atp_statusNotifHi. Its value should be
    0,1,...,9. Where 0 means no highlight for status notification (which is
    the default).  If it is set to positive value then the default values of
    these variables should give the same colour as the status line has.

    							*b:atp_StatusLine*
    The variable |b:atp_StatusLine| is stores the value of Vim option
    'statusline'; actually 'statusline' option is set by: >
		set statusline=%!b:atp_StatusLine
<

================================================================================
ATP DEVELOPMENT						*atp-development*

g:atp_atpdev = 0					*g:atp_atpdev*
If you set this to 1 the following command will be available.
:DebugPrint 						*atp-:DebugPrint*
    if you want to develop/debug ATP set g:atp_atpdev to 1 run
    |atp-:ReloadATP| and this command will allow to print (cat) debug
    files under |g:atp_TempDir|.

Debug information is accessible for almost every function, but it is turned
off by default.  The variable names for that are g:atp_depub{FunctionName},
where {FunctionName} is or name of the function or an abbreviation.  See
section in ftplugin/ATP_files/options.vim script.

================================================================================
FINAL REMARKS                               		*atp-remarks*
	
	To see some messages that are issued you can use the |:mes| command.

	If you find this plugin useful and have some comments you are
	cordially invited to write to the author: <mszamot [AT] gmail [dot]
	com>, add some "karma" points on vim script page, make
	a recommendation or write a review on SourceForge: |atp-sourceforge|.

	Best, and hopefully you will find this useful :) 
	Marcin Szamotulski
	
	
================================================================================
COPY RIGHTS						*atp-copy-rights*


    Copyright (C) 2010, 2011, 2012, 2013 Marcin Szamotulski Permission is
    hereby granted to use and distribute this code, with or without
    modifications, provided that this copyright notice is copied with it. 

    Automatic Tex Plugin for Vim is free software: you can redistribute it
    and/or modify it under the terms of the GNU General Public License as
    published by the Free Software Foundation, either version 3 of the
    License, or (at your option) any later version.
 
    Automatic Tex Plugin for Vim is distributed in the hope that it will be
    useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
    Public License for more details.
 
    You should have received a copy of the GNU General Public License along
    with Automatic Tex Plugin for Vim.  If not, see <http://www.gnu.org/licenses/>.

    This licence applies to all files shipped with Automatic Tex Plugin,
    excluding the following two dictionary files: >
	"ftplugin/ATP_files/dictionaries/dictionary",
	"ftplugin/ATP_files/dictionaries/SIunits" 
<   where taken from latex-suite Vim plugin and are under Vim charity license.

    USE AT-YOUR-OWN-RISK.

 vim:tw=78:ts=8:ft=help:norl:
